# 线性结构和非线性结构

- 线性结构包括：数组（顺序表）、链表、栈、队列
- 非线性结构包括：二维数组、多维数组、广义表、树、图

# 稀疏数组

- 可压缩数组大小，减少存储空间
- 应用：如五子棋棋盘（二维数组转换成稀疏数组）的存储

```
    public static void main(String[] args) throws IOException {
        // 创建初始二维数组，0表示没有棋子，1表示黑棋，2表示白棋
        int[][] chessArr = new int[11][11];
        chessArr[1][2] = 1;
        chessArr[2][3] = 2;
        chessArr[3][4] = 1;
        // 打印出原始棋盘，并求出非零元素的个数
        System.out.println("原始棋盘：");
        int count = printChessArr(chessArr);

        System.out.println("------------------------------");

        // 将二维数组转换成稀疏数组并打印
        int[][] sparseArr = new int[count + 1][3];
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = count;
        int k = 1;
        for (int i = 0; i < 11; ++i) {
            for (int j = 0; j < 11; ++j) {
                if (chessArr[i][j] != 0) {
                    sparseArr[k][0] = i;
                    sparseArr[k][1] = j;
                    sparseArr[k][2] = chessArr[i][j];
                    ++k;
                }
            }
        }
        System.out.println("稀疏数组：");
        printChessArr(sparseArr);

        System.out.println("------------------------------");

        /* 该稀疏数组可存储到磁盘中 */
        BufferedWriter out = new BufferedWriter(new FileWriter("D:\\IDEA\\IdeaProject\\MyProject2\\myTest\\map.data"));
        for (int[] row : sparseArr) {
            for (int data : row)
                out.write(data + ",");
            out.write("\r\n");
        }
        out.close();

        /* 从磁盘中读取稀疏数组 */
        BufferedReader in = new BufferedReader(new FileReader("D:\\IDEA\\IdeaProject\\MyProject2\\myTest\\map.data"));
        String line = null;
        int lineNum = 0;
        while ((line = in.readLine()) != null) {
            String[] nums = line.split(",");
            for (int i = 0; i < 2; ++i)
                sparseArr[lineNum][i] = Integer.parseInt(nums[i]);
            ++lineNum;
        }

        // 将稀疏数组再转换成二维数组并打印
        int rows = sparseArr[0][0];
        int cols = sparseArr[0][1];
        int num = sparseArr[0][2];
        int[][] chessArr2 = new int[rows][cols];
        for (int i = 1; i <= num; ++i) {
            int row = sparseArr[i][0];
            int col = sparseArr[i][1];
            int data = sparseArr[i][2];
            chessArr2[row][col] = data;
        }
        System.out.println("从稀疏数组恢复的棋盘：");
        printChessArr(chessArr2);
    }

    /**
     * @param arr 要打印的二维数组
     * @return arr中非零元素的个数
     */
    private static int printChessArr(int[][] arr) {
        int count = 0;
        for (int[] row : arr) {
            for (int data : row) {
                System.out.printf("%d\t", data);
                if (data != 0)
                    ++count;
            }
            System.out.println();
        }
        return count;
    }
```

# 逆波兰表达式（后缀表达式）

- 计算机计算后缀表达式最容易

## 将中缀表达式转换成逆波兰表达式(后缀表达式)

- 思路：使用一个StringBuilder和一个存储符号的栈扫描中缀表达式
 - 扫描到操作数则直接append到StringBulider中
 - 扫描到符号时：
 1. 若栈空，或为左括号，直接压栈；
 2. 若为右括号，则将栈顶符号弹栈并append到StringBulider中，直到遇到左括号，弹栈但不append；
 3. 若为加/减/乘/除，若优先级比栈顶符号的优先级高，则直接压栈，否则先将栈顶符号弹栈并append，再压栈；
 4. 扫描结束后，将栈中符号逐个弹栈并append


```
    /**
     * 将中缀表达式转换成逆波兰表达式
     * @param exp 中缀表达式
     * @return 逆波兰表达式
     */
    private static String toReversePolish(String exp) {
        String[] split = exp.split(" ");
        StringBuilder sb = new StringBuilder();
        Stack<String> stack = new Stack<>();    // 运算符堆栈
        for (String ele : split) {
            if (ele.matches("\\d+"))    // ele是操作数，直接append
                sb.append(ele).append(" ");
            else {  // ele是操作符
                 if (")".equals(ele)) {    // ele是右括号，将栈中元素弹栈并append，直到遇到左括号
                     while (!"(".equals(stack.peek())) {
                         sb.append(stack.pop()).append(" ");
                     }
                     stack.pop();
                 } else if (stack.isEmpty() || "(".equals(stack.peek()) || "(".equals(ele)) {    // 栈为空或栈顶元素为左括号或ele为左括号，压栈
                     stack.push(ele);
                 } else {   // ele为加减乘除，栈不为空，且栈顶元素不为左括号，要比较ele和栈顶元素的优先级
                     String topOp = stack.peek();
                     if (!(("*".equals(ele) || "/".equals(ele)) && ("+".equals(topOp) || "-".equals(topOp)))) {
                         sb.append(stack.pop()).append(" ");
                     }
                     stack.push(ele);
                 }
            }
        }
        while (!stack.empty())
            sb.append(stack.pop()).append(" ");

        return sb.toString();
    }
```

## 计算逆波兰表达式

- 思路：使用一个存储操作数的栈
 - 扫描逆波兰表达式
 - 扫描到操作数，则压栈
 - 扫描到符号，则从栈中弹出两个元素，进行相应运算(注意：先弹栈的为第二个操作数)，再将结果压栈

```
    /**
     * 计算逆波兰表达式
     * @param re 逆波兰表达式
     * @return 逆波兰表达式的结果
     */
    private static int calculateRePolish(String re) {
        String[] split = re.split(" ");
        Stack<Integer> stack = new Stack<>();

        for (String ele : split) {
            if (ele.matches("\\d+"))    // 是数字，则压入堆栈
                stack.push(Integer.parseInt(ele));
            else {  // 是运算符，则弹栈两个操作数，进行运算后将结果压入堆栈
                int a = stack.pop();
                int b = stack.pop();
                stack.push(operate(a, b, ele));	// 注意：若为减法或除法，应是"b-a"或"b/a"
            }
        }

        return stack.pop();   // 最终堆栈中剩下的数字就是结果
    }
```

# 递归回溯法

## 迷宫问题

```
    public static void main(String[] args) {
        int[][] maze = createMaze();
        System.out.println("---------初始迷宫---------");
        printMaze(maze);
        setWay(maze, 1, 1);
        System.out.println("-------走过后的迷宫-------");
        printMaze(maze);
    }

    /**
     * 走迷宫(策略为：下 - 右 - 上 - 左)
     * @param maze 迷宫
     * @param i 起始点的行号
     * @param j 起始点的列号
     * @return true-能走到出口   false-不能走到出口
     */
    private static boolean setWay(int[][] maze, int i, int j) {
        if (i == 6 && j == 5) { // 已走到迷宫出口
            maze[i][j] = 2;
            return true;
        } else if (maze[i][j] == 0) {   // 该点不是墙但未走过，将该点设为已走过，且假定不是死路
            maze[i][j] = 2;
            // 策略：下 -> 右 -> 上 -> 左 （递归，若都走不通则回溯，一直回溯到上一个有路可走的点）
            if (setWay(maze, i + 1, j) || setWay(maze, i, j + 1) ||
                    setWay(maze, i - 1, j) || setWay(maze, i, j - 1))   // 如该点向下走能到达出口(递归返回true)，该点就不再走其他方向
                return true;
            else {  // 发现该点上下左右都走不通，是死路
                maze[i][j] = 3;
                return false;
            }
        } else {    // 该点是墙或已走过
            return false;
        }
    }

    /**
     * 打印迷宫 (0表示未走过，1表示墙，2表示已走过的通路，3表示已走过的死路)
     * @param maze 迷宫
     */
    private static void printMaze(int[][] maze) {
        for (int[] rows : maze) {
            for (int ele : rows)
                System.out.print(ele + "\t");
            System.out.println();
        }
    }

    /**
     * 创建迷宫
     * @return 用二维数组表示的迷宫 1表示墙 0表示通路
     */
    private static int[][] createMaze() {
        int[][] maze = new int[8][7];

        // 设置四周的墙
        for (int i = 0; i < 7; ++i) {
            maze[0][i] = 1;
            maze[7][i] = 1;
        }
        for (int i = 1; i < 7; ++i) {
            maze[i][0] = 1;
            maze[i][6] = 1;
        }

        // 设置中间的挡板
        maze[2][2] = 1;
        maze[2][3] = 1;
        maze[2][4] = 1;
        maze[3][4] = 1;
        maze[4][4] = 1;
        maze[5][4] = 1;
        maze[5][3] = 1;
        maze[5][2] = 1;
        maze[5][1] = 1;

        return maze;
    }
```

## 八皇后问题

```
public class EightQueenDemo {
    // 用一维数组queens[]表示八皇后摆放的位置，如queen[i] = j，表示第 (i+1) 个皇后摆放在 [i, j] 位置
    static final int MAX = 8;
    static int[] queens = new int[MAX];

    static int count = 0;   // 用于记录总共有多少种不同的摆放方式

    public static void main(String[] args) {
        check(0);   // 从第1个皇后开始摆放
        System.out.println("count = " + count);
    }

    /**
     * 在第(n+1)行摆放第(n+1)个皇后
     * @param n 即表示第(n+1)个皇后，又表示摆放在第(n+1)行
     */
    private static void check(int n) {
        if (n == MAX) { // 八皇后已经摆放完毕，输出结果并计数
            printQueens(queens);
            ++count;
            return;
        }

        for (int i = 0; i < MAX; ++i) {
            queens[n] = i;  // 本行皇后摆放在第(i+1)列
            if (judge(n))   // 判断，若摆放在该列没有冲突，则摆放下一个皇后，若有冲突，则摆放在本行下一列继续判断
                check(n + 1);
        }
    }

    /**
     * 摆放第(n+1)个皇后时，判断是否和之前摆放的n个皇后有冲突
     */
    private static boolean judge(int n) {
        for (int i = 0; i < n; ++i) {
            // queens[i] == queens[n] 表示第(i+1)个皇后和第(n+1)个皇后在同一列
            // Math.abs(i - n) == Math.abs(queens[i] - queens[n]) 表示第(i+1)个皇后和第(n+1)个皇后在同一斜线
            // 无需判断是否在同一行，因为n既代表第(n+1)个皇后，又代表第(n+1)行
            if (queens[i] == queens[n] || Math.abs(i - n) == Math.abs(queens[i] - queens[n]))
                return false;
        }
        return true;
    }

    /**
     * 用于打印八皇后的摆放位置
     */
    private static void printQueens(int[] queens) {
        System.out.println(Arrays.toString(queens));
    }
```

## 马踏棋盘算法（骑士周游算法）

- 规则：马走"日"字，要求将棋盘上每个格子走完，且不能重复走
- 利用贪婪算法进行优化

```
public class HorseSteppingChessboardDemo {
    public static void main(String[] args) {
        int rowNum = 8, colNum = 8;   // 大小为 rowNum * colNum 的棋盘
        int[][] chessboard = new int[rowNum][colNum];
        int startX = 0, startY = 0; // 起始点[startX, startY]

        System.out.println("马踏棋盘算法（骑士周游算法）开始...");
        long l1 = System.currentTimeMillis();

        horseStepping(chessboard, startX, startY, 1);   // 执行马踏棋盘算法

        long l2 = System.currentTimeMillis();
        // 某些情况下，可能无法完成马踏棋盘任务，需要判断
        if (finished) {
            System.out.println("总时间：" + (l2 - l1) + "ms");

            for (int[] rows : chessboard) {
                for (int step : rows)
                    System.out.print(step + " ");
                System.out.println();
            }
        } else
            System.out.println("该棋盘在该起始点无法完成马踏棋盘任务...");
    }

    private static boolean finished;    // 记录马踏棋盘任务是否完成，初始为false

    /**
     * 马踏棋盘算法
     * @param chessboard 棋盘 chessboard[i][j] = 0，表示该点未走过  chessboard[i][j] = k，表示该点在第k步走过
     * @param x 当前所在的横坐标
     * @param y 当前所在的纵坐标
     * @param step 步数（起始点step=1）
     */
    private static void horseStepping(int[][] chessboard, int x, int y, int step) {
        int rowNum = chessboard.length; // 总行数
        int colNum = chessboard[0].length;  // 总列数

        chessboard[x][y] = step;    // 记录下步数，也即将该点置为已走过
        ArrayList<Point> nextSelects = getNextSelects(rowNum, colNum, new Point(x, y)); // 获取可走点集合

        /* 利用贪婪算法进行优化，每次选取下一步时，应使下一步的下一步最少，以减少回溯次数 */
        // 如果不加这句排序，则耗费的时间会多很多
//        nextSelects.sort((o1, o2) -> getNextSelects(rowNum, colNum, o1).size() - getNextSelects(rowNum, colNum, o2).size());  // 直接使用Lambda表达式的写法
        nextSelects.sort(Comparator.comparingInt(o -> getNextSelects(rowNum, colNum, o).size()));   // 将可走点按其下一步可走点的数量从小到大排序

        while (!nextSelects.isEmpty()) {
            // 取下一步可走点最少的可走点，判断是否访问过，若没访问过，则访问，否则取下一个
            Point nextPoint = nextSelects.remove(0);
            if (chessboard[nextPoint.x][nextPoint.y] == 0)
                horseStepping(chessboard, nextPoint.x, nextPoint.y, step + 1);
        }

        /* 若已完成，要将finished置为true；若走不通，要将棋盘置零 */
        if (step == rowNum * colNum)
            finished = true;    // 当走完时，将finished置为true，开始回溯
        else {  // step < rowNum * colNum，有两种情况(1. 此路不通，正在回溯  2.已完成马踏棋盘任务，正在回溯)，用finished来判断
            if (!finished)  // 若执行到此步finished仍未false，说明此路不通，要将该点置为未访问过
                chessboard[x][y] = 0;
        }
    }

    /**
     * 获取存储着可走点的ArrayList (最多有8个可走点)
     * @param rowNum 总行数
     * @param colNum 总列数
     * @param nowPoint 现在所在的点
     * @return 存储着可走点的ArrayList
     */
    private static ArrayList<Point> getNextSelects(int rowNum, int colNum, Point nowPoint) {
        ArrayList<Point> nextSelects = new ArrayList<>();

        // 判断可能的8个可走点是否真的可走（只考虑是否在棋盘内，不考虑是否已走过），若可走则添加到nextSelects
        if (nowPoint.x - 2 >= 0 && nowPoint.y + 1 < colNum)
            nextSelects.add(new Point(nowPoint.x - 2, nowPoint.y + 1));
        if (nowPoint.x - 1 >= 0 && nowPoint.y + 2 < colNum)
            nextSelects.add(new Point(nowPoint.x - 1, nowPoint.y + 2));
        if (nowPoint.x + 1 < rowNum && nowPoint.y + 2 < colNum)
            nextSelects.add(new Point(nowPoint.x + 1, nowPoint.y + 2));
        if (nowPoint.x + 2 < rowNum && nowPoint.y + 1 < colNum)
            nextSelects.add(new Point(nowPoint.x + 2, nowPoint.y + 1));
        if (nowPoint.x + 2 < rowNum && nowPoint.y - 1 >= 0)
            nextSelects.add(new Point(nowPoint.x + 2, nowPoint.y - 1));
        if (nowPoint.x + 1 < rowNum && nowPoint.y - 2 >= 0)
            nextSelects.add(new Point(nowPoint.x + 1, nowPoint.y - 2));
        if (nowPoint.x - 1 >= 0 && nowPoint.y - 2 >= 0)
            nextSelects.add(new Point(nowPoint.x - 1, nowPoint.y - 2));
        if (nowPoint.x - 2 >= 0 && nowPoint.y - 1 >= 0)
            nextSelects.add(new Point(nowPoint.x - 2, nowPoint.y - 1));

        return nextSelects;
    }
}
```

# 排序算法

## 归并排序（分治法）

```
    public static void main(String[] args) {
        int[] arr = {49, 38, 65, 97, 76, 13, 27, 49, 55, 4};

        System.out.println("---初始序列---");
        System.out.println(Arrays.toString(arr));

        System.out.println("---归并排序后---");
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 归并排序，范围是arr[]数组的[low, high]
     */
    private static void mergeSort(int[] arr, int low, int high) {
        if (low >= high)
            return;

        int mid = (low + high) / 2;
        // 分而治之
        mergeSort(arr, low, mid);
        mergeSort(arr, mid + 1, high);
        merge(arr, low, mid, high);
    }

    /**
     * 将两个子序列 ([low, mid]和[mid + 1, high])分别有序的序列arr[]，归并成[low, high]完全有序
     */
    private static void merge(int[] arr, int low, int mid, int high) {
        int size = high - low + 1;
        int[] temp = new int[size]; // 将合并后的序列先存在temp[]中

        int i = low, j = mid + 1;   // i和j分别用于遍历分别有序的两个子序列
        int k = 0;  // k用于遍历temp[]

        while (i <= mid && j <= high) {
            if (arr[i] <= arr[j])
                temp[k++] = arr[i++];
            else
                temp[k++] = arr[j++];
        }

        while (i <= mid)
            temp[k++] = arr[i++];
        while (j <= high)
            temp[k++] = arr[j++];

        System.arraycopy(temp, 0, arr, low, size);  // 将temp[]中合并好的序列copy到arr[]相应位置中
    }
```

## 快速排序

```
    public static void main(String[] args) {
        int[] arr = {49, 38, 65, 97, 76, 13, 27, 49, 55, 4};

        System.out.println("---初始序列---");
        System.out.println(Arrays.toString(arr));

        quickSort(arr, 0, arr.length - 1);

        System.out.println("---快速排序后---");
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 快速排序 排序范围是arr[]数组的[low, high]
     */
    private static void quickSort(int[] arr, int low, int high) {
        if (low >= high)
            return;

        int temp = arr[low];
        int i = low, j = high;
        while (i < j) {
            while (i < j && arr[j] >= temp)
                --j;

            if (i < j) {
                arr[i] = arr[j];
                ++i;
            }

            while (i < j && arr[i] <= temp)
                ++i;

            if (i < j) {
                arr[j] = arr[i];
                --j;
            }
        }
        arr[i] = temp;

        quickSort(arr, low, i - 1);
        quickSort(arr, i + 1, high);
    }
```

## 希尔排序（缩小增量排序）

```
    public static void main(String[] args) {
        int[] arr = {49, 38, 65, 97, 76, 13, 27, 49, 55, 4};

        System.out.println("---初始序列---");
        System.out.println(Arrays.toString(arr));

        shellSort(arr);

        System.out.println("---希尔排序后---");
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 希尔排序
     */
    private static void shellSort(int[] arr) {
        int count = 1;
        for (int gap = arr.length / 2; gap >= 1; gap /= 2) {    // gap为增量，不断缩小
            for (int i = 0; i < gap; ++i) {
                // 对每个子序列(i, i+gap, i+gap+gap, ...)进行直接插入排序
                int index = i + gap;

                while (index < arr.length) {
                    int num = arr[index];
                    int j = index - gap;
                    while (j >= 0 && arr[j] > num) {
                        arr[j + gap] = arr[j];
                        j -= gap;
                    }
                    arr[j + gap] = num;
                    index += gap;
                }
            }
            System.out.println("第" + count + "趟排序，gap = " + gap);
            ++count;
            System.out.println(Arrays.toString(arr));
        }
    }
```

## 堆排序

- 用顺序存储二叉树的形式（用数组表示二叉树）

```
    public static void main(String[] args) {
        int[] arr = {49, 38, 65, 97, 76, 13, 27, 49, 55, 4};

        System.out.println("---初始序列---");
        System.out.println(Arrays.toString(arr));

        heapSort(arr);

        System.out.println("---堆排序后---");
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 堆排序
     * @param arr 待排序序列
     */
    private static void heapSort(int[] arr) {
        // 创建初始堆
        for (int i = (arr.length-2) / 2; i >=0; --i) // 从第一个非叶子结点开始调整（ 下标为(arr.length-2)/2 ）
            heapAdjust(arr, i, arr.length - 1);

        System.out.println("初始堆：");
        System.out.println(Arrays.toString(arr));

        // 堆排序过程，每次选出剩余元素的最大值，放到末尾
        for (int i = 0; i < arr.length - 1; ++i) {
            heapAdjust(arr, 0, arr.length - i - 1); // 此时只需要调整根结点，因为只有根节点是从后面换上来的
            swap(arr, 0, arr.length - i - 1);   // 将每次排序出的最小值放到后面

            System.out.println("第" + (i+1) + "趟堆排序：");
            System.out.println(Arrays.toString(arr));
        }
    }

    /**
     * 调整堆
     * @param arr 堆
     * @param low 调整的起始结点
     * @param high 调整的终止结点
     */
    private static void heapAdjust(int[] arr, int low, int high) {
        int i = low, j = 2 * i + 1;
        int temp = arr[low];
        while (j <= high) {
            if (j < high && arr[j+1] > arr[j])
                ++j;    // j定位到i的左右子树中的较大者

            if (arr[j] > temp) {
                arr[i] = arr[j];
                i = j;
                j = 2 * i + 1;
            } else // 如果此处不需调整，那么下面也不需调整（若忘写，会造成死循环!!）
                break;
        }
        arr[i] = temp;  // 将temp放入在此次堆调整后的最终位置
    }
```

# 查找算法

## 插入二分查找法

- 插入二分查找法是二分查找法的改进，适用于元素较多且较为连续的有序数组
- 思想：取自适应的mid，即`mid = low + (high - low) * ((key - arr[low]) / (arr[high] - arr[low]))`

```
    /**
     * 插值二分查找法
     * @param arr 要查找的数组
     * @param key 要查找的元素
     * @return 元素在数组中的索引
     */
    private static int insertBinarySearch(int[] arr, int key) {
        int low = 0, high = arr.length - 1;
        int mid;
        while (low <= high) {
            mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]);   // 传统的二分查找法 mid=(low + high)/2
            if (key < arr[mid])
                high = mid - 1;
            else if (key > arr[mid])
                low = mid + 1;
            else
                return mid;
        }
        return -1;
    }
```

## 斐波那契查找法(黄金分割查找法)

- 斐波那契查找法(黄金分割查找法)是二分查找法的改进（要求序列有序，且**可能需要用数组最后一个元素进行扩展序列**）
- 思路：采用斐波那契数列确定mid，即**`mid = low + Fib[k-1] - 1`**（Fib[]是斐波那契数列，k是使得`Fib[k] >= arr.length`成立的最小整数）
 - 斐波那契数列的相邻两项的比值接近黄金分割比
 - 斐波那契数列：{1, 1, 2, 3, 5, 8, 13, 21, 34, ...}，即当 k>=2 时，`Fib[k] = Fib[k-1] + Fib[k-2]`
 - 也即`Fib[k] - 1 = (Fib[k-1] - 1) + (Fib[k-2] - 1) + 1`
 - **当序列长度正好为Fib[k]时**（若序列长度不为 Fib[k]-1，需要扩展序列），**`mid = low + Fib[k-1] - 1`，此时mid前面有(F[k-1] - 1)个元素，后面有(F[k-2] - 1)个元素**
 - **若key在mid前面，则下次查找时k要减1；若key在mid后面，则下次查找时k要减2**

```
    static int maxSize = 10;
    public static void main(String[] args) {
        int[] arr = {1, 8, 10, 51, 89, 1000, 1234};
        int key = 1234;
        int index = fibonacciSearch(arr, key);
        System.out.println("index = " + index);
    }

    /**
     * 斐波那契查找法(黄金分割查找法)
     * @param arr 数组
     * @param key 要找的值
     * @return key在arr[]中的索引（若未找到，返回-1）
     */
    private static int fibonacciSearch(int[] arr, int key) {
        int[] fib = getFibonacci(maxSize);
//        System.out.println(Arrays.toString(fib));

        int low = 0, high = arr.length - 1;
        int mid;

        // 找到正好使得 fib(k) >= arr.length 成立的最小k
        int k = 0;
        while (fib[k] < arr.length)
            ++k;

        // 如果 arr.length < fib[k]，则需要扩展
        int[] temp = Arrays.copyOf(arr, fib[k]);    // 将arr[]的长度扩展成fib[k]（Arrays.copyOf()方法是用0填充的）
        // 为了能够进行查找，要将填充的0换成序列最后一个元素
        for (int i = high + 1; i < temp.length; ++i)
            temp[i] = temp[high];

//        System.out.println(Arrays.toString(arr));
//        System.out.println(Arrays.toString(temp));

        while (low <= high) {
            mid = low + fib[k-1] - 1;   // mid前面有(fib[k-1]-1)个元素，后面有(fib[k-2]-1)个元素

            if (temp[mid] > key) {
                high = mid - 1;
                k -= 1; // 左子序列长度和fib[k-1]相等
            } else if (temp[mid] < key) {
                low = mid + 1;
                k -= 2; // 右子序列长度和fib[k-2]相等
            } else {  // 找到，要判断位置是原序列中的位置还是用填充的位置
                if (mid < arr.length)
                    return mid;
                else
                    return arr.length - 1;
            }
        }
        return -1;
    }

    /**
     * 获取斐波那契数列
     * @param len 斐波那契数列的长度
     * @return 长度为len的斐波那契数列
     */
    private static int[] getFibonacci(int len) {
        int[] f = new int[len];
        f[0] = f[1] = 1;
        for (int i = 2; i < len; ++i)
            f[i] = f[i-2] + f[i-1];
        return f;
    }
```

# 树

## 二叉树

- 二叉树的前序/中序/后序遍历
- 二叉树的前序查找/中序查找/后序查找
- 二叉树结点的删除

- **要点：结点是一个类，树是另一个类**

```
public class BinaryTreeDemo {
    public static void main(String[] args) {
        // 先手动创建二叉树结点之间的关系，后面可递归创建
        Node node1 = new Node(1);
        Node node2 = new Node(2);
        Node node3 = new Node(3);
        Node node4 = new Node(4);
        Node node5 = new Node(5);
        node1.lChild = node2;
        node1.rChild = node3;
        node2.lChild = node4;
        node2.rChild = node5;

        // 将node1置为二叉树的根节点
        BTree tree = new BTree(node1);

//        System.out.println("前序遍历：");
//        tree.preOrder();
//        System.out.println();
//
//        System.out.println("中序遍历：");
//        tree.inOrder();
//        System.out.println();
//
//        System.out.println("后序遍历：");
//        tree.postOrder();
//        System.out.println();
//
        int key = 6;
//        System.out.println(tree.preOrderSearch(key));
//        System.out.println(tree.inOrderSearch(key));
//        System.out.println(tree.postOrderSearch(key));

        System.out.println("删除前 前序遍历：");
        tree.preOrder();
        System.out.println();

        if (tree.delNode(key)) {
            System.out.println("删除后 前序遍历：");
            tree.preOrder();
            System.out.println();
        } else
            System.out.println("删除失败，未找到该结点");
    }
}

// 二叉树类
class BTree {
    public Node root;   // 二叉树的根节点

    /**
     * 删除结点
     * @param key 待删除结点的关键字
     * @return true-删除成功 false-删除失败（未找到该结点）
     */
    public boolean delNode(int key) {
        if (this.root == null)
            return false;

        if (this.root.val == key) { // 根结点无双亲结点，必须立即判断，若根结点就是待删除结点，则将树置空
            root = null;
            return true;
        } else {    // 若根结点不是待删除结点，则开始递归
            return this.root.delNode(key);
        }
    }

    /**
     * 前序查找
     * @param key 要查找的关键字
     * @return 该关键字所在的结点 若未找到则返回null
     */
    public Node preOrderSearch(int key) {
        if (this.root == null)
            return null;

        return this.root.preOrderSearch(key);
    }

    /**
     * 中序查找
     * @param key 要查找的关键字
     * @return 该关键字所在的结点 若未找到则返回null
     */
    public Node inOrderSearch(int key) {
        if (this.root == null)
            return null;

        return this.root.inOrderSearch(key);
    }

    /**
     * 后序查找
     * @param key 要查找的关键字
     * @return 该关键字所在的结点 若未找到则返回null
     */
    public Node postOrderSearch(int key) {
        if (this.root == null)
            return null;

        return this.root.postOrderSearch(key);
    }

    /**
     * 前序遍历
     */
    public void preOrder() {
        if (this.root != null)
            this.root.preOrder();
        else
            System.out.println("树为空");
    }

    /**
     * 中序遍历
     */
    public void inOrder() {
        if (this.root != null)
            this.root.inOrder();
        else
            System.out.println("树为空");
    }

    /**
     * 后序遍历
     */
    public void postOrder() {
        if (this.root != null)
            this.root.postOrder();
        else
            System.out.println("树为空");
    }

    public BTree(Node root) {
        this.root = root;
    }
}

// 二叉树结点类
class Node {
    public int val;
    public Node lChild;
    public Node rChild;

    /**
     * 删除指定结点（若待删除结点有子树，则一并删除）
     * 注意：删除结点要在其双亲结点上操作
     * @param key 待删除结点的关键字
     * @return true-删除成功 false-删除失败（未找到该结点）
     */
    public boolean delNode(int key) {
        // 因为删除结点要在待删除结点的双亲结点上操作，因此是判断子结点的值
        if (this.lChild != null && this.lChild.val == key) {
            this.lChild = null;
            return true;
        }
        if (this.rChild != null && this.rChild.val == key) {
            this.rChild = null;
            return true;
        }

        if (this.lChild != null) {
            if (this.lChild.delNode(key))
                return true;
        }

        if (this.rChild != null)
            return this.rChild.delNode(key);

        return false;
    }

    /**
     * 前序查找
     * @param key 要查找的关键字
     * @return 该关键字所在的结点 若未找到则返回null
     */
    public Node preOrderSearch(int key) {
        if (this.val == key)
            return this;

        Node node = null;
        if (this.lChild != null)
            node = this.lChild.preOrderSearch(key);
        if (node != null)
            return node;

        if (this.rChild != null)
            node = this.rChild.preOrderSearch(key);

        return node;
    }

    /**
     * 中序查找
     * @param key 要查找的关键字
     * @return 该关键字所在的结点 若未找到则返回null
     */
    public Node inOrderSearch(int key) {
        Node node = null;
        if (this.lChild != null)
            node = this.lChild.inOrderSearch(key);
        if (node != null)
            return node;

        if (this.val == key)
            return this;

        if (this.rChild != null)
            node = this.rChild.inOrderSearch(key);
        return node;
    }

    /**
     * 后序查找
     * @param key 要查找的关键字
     * @return 该关键字所在的结点 若未找到则返回null
     */
    public Node postOrderSearch(int key) {
        Node node = null;
        if (this.lChild != null)
            node = this.lChild.postOrderSearch(key);
        if (node != null)
            return node;

        if (this.rChild != null)
            node = this.rChild.postOrderSearch(key);
        if (node != null)
            return node;

        if (this.val == key)
            return this;
        else
            return null;
    }

    /**
     * 前序遍历
     */
    public void preOrder() {
        System.out.print(this + "\t");

        if (this.lChild != null)
            this.lChild.preOrder();

        if (this.rChild != null)
            this.rChild.preOrder();
    }

    /**
     * 中序遍历
     */
    public void inOrder() {
        if (this.lChild != null) {
            this.lChild.inOrder();
        }

        System.out.print(this + "\t");

        if (this.rChild != null)
            this.rChild.inOrder();
    }

    /**
     * 后序遍历
     */
    public void postOrder() {
        if (this.lChild != null)
            this.lChild.postOrder();

        if (this.rChild != null)
            this.rChild.postOrder();

        System.out.print(this + "\t");
    }

    @Override
    public String toString() {
        return "BTree{" +
                "val=" + val +
                '}';
    }

    public Node(int val) {
        this.val = val;
    }
}
```

- 递归创建（完全）二叉树

```
    /**
     * 创建二叉树（完全二叉树）
     * @param arr 结点序列
     * @return 根节点
     */
    private static BTNode createTree(int[] arr) {
        if (arr == null || arr.length == 0)
            return null;

        return createTree(arr, 0);
    }

    /**
     * 创建二叉树（完全二叉树）
     * @param arr 结点序列
     * @param n 根节点索引
     * @return 根节点
     */
    private static BTNode createTree(int[] arr, int n) {
        if (n >= arr.length)
            return null;

        BTNode curr = new BTNode(arr[n]);
        curr.lChild = createTree(arr, 2 * n + 1);
        curr.rChild = createTree(arr, 2 * n + 2);

        return curr;
    }
```

## 顺序存储二叉树

- 用数组存储二叉树的结构，要求仍能够进行前序、中序、后序遍历

```
public class ArrayBinaryTreeDemo {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7};
        ArrayBinaryTree arrayBinaryTree = new ArrayBinaryTree(arr);

        System.out.print("前序遍历：");
        arrayBinaryTree.preOrder();
        System.out.println();

        System.out.print("中序遍历：");
        arrayBinaryTree.inOrder();
        System.out.println();

        System.out.print("后序遍历：");
        arrayBinaryTree.postOrder();
        System.out.println();
    }
}

class ArrayBinaryTree {
    private int[] arr;

    /**
     * 后序遍历
     * @param index 开始遍历的结点序号(结点序号从0开始)
     */
    public void postOrder(int index) {
        if (this.arr == null || this.arr.length == 0)
            System.out.println("树为空");

        if (2 * index + 1 < arr.length)
            postOrder(2 * index + 1);

        if (2 * index + 2 < arr.length) {
            postOrder(2 * index + 2);
        }

        System.out.print(arr[index] + " ");
    }

    /**
     * 后序遍历(从根节点开始)
     */
    public void postOrder() {
        postOrder(0);
    }

    /**
     * 中序遍历
     * @param index 开始遍历的结点序号(结点序号从0开始)
     */
    public void inOrder(int index) {
        if (this.arr == null || this.arr.length == 0)
            System.out.println("树为空");

        if (2 * index + 1 < arr.length)
            inOrder(2 * index + 1);

        System.out.print(arr[index] + " ");

        if (2 * index + 2 < arr.length)
            inOrder(2 * index + 2);
    }

    /**
     * 中序遍历(从根节点开始)
     */
    public void inOrder() {
        inOrder(0);
    }

    /**
     * 前序遍历
     * @param index 开始遍历的结点序号(结点序号从0开始)
     */
    public void preOrder(int index) {
        if (this.arr == null || this.arr.length == 0)
            System.out.println("树为空");

        System.out.print(arr[index] + " ");

        if (2 * index + 1 < arr.length)
            preOrder(2 * index + 1);
        if (2 * index + 2 < arr.length)
            preOrder(2 * index + 2);
    }

    /**
     * 前序遍历(从根节点开始)
     */
    public void preOrder() {
        preOrder(0);
    }

    public ArrayBinaryTree(int[] arr) {
        this.arr = arr;
    }
}
```

## 线索二叉树的创建和遍历

- **要点：需要一个pre指向前驱结点，而pre是线索二叉树的属性，而非结点属性**

### 中序线索二叉树

```
public class ThreadBinaryTreeDemo {
    public static void main(String[] args) {
        int[] arr = {49, 38, 65, 97, 76, 13, 27, 49, 55, 4};
        TBTNode root = createTree(arr);
        ThreadBTree tbt = new ThreadBTree(root);
        tbt.inThreading();
        tbt.inOrder();
    }

    /**
     * 创建二叉树（完全二叉树）
     * @param arr 结点序列
     * @return 根节点
     */
    private static TBTNode createTree(int[] arr) {
        if (arr == null || arr.length == 0)
            return null;

        return createTree(arr, 0);
    }

    /**
     * 创建二叉树（完全二叉树）
     * @param arr 结点序列
     * @param n 根节点索引
     * @return 根节点
     */
    private static TBTNode createTree(int[] arr, int n) {
        if (n >= arr.length)
            return null;

        TBTNode curr = new TBTNode(arr[n]);
        curr.lChild = createTree(arr, 2 * n + 1);
        curr.rChild = createTree(arr, 2 * n + 2);

        return curr;
    }
}

// 线索二叉树类
class ThreadBTree {
    public TBTNode root;   // 线索二叉树的根结点
    public TBTNode pre;    // 为了进行线索化，需要记录直接前驱 (注意：pre是树的属性，而非结点的属性，初始为null)

    /**
     * 利用中序线索化二叉树进行中序遍历
     */
    public void inOrder() {
        if (this.root == null) {
            System.out.println("树为空");
            return;
        }

        TBTNode node = this.root;
        while (node != null) {
            while (node.lTag == 0)  // 将node指向最左下结点
                node = node.lChild;

            System.out.print(node + " ");   // 访问node

            while (node.rTag == 1) {    // 若rChild为直接后继，则访问，直到rChild是右子树为止
                node = node.rChild;
                System.out.print(node + " ");
            }

            node = node.rChild; // 此时node有右子树，没有左子树，且node已经被访问过，将其右子树作为根进行中序遍历
        }
    }

    /**
     * 中序线索化
     */
    public void inThreading() {
        inThreading(this.root);
    }

    /**
     * 中序线索化 (遵循中序遍历的框架)
     * @param node 待线索化结点
     */
    public void inThreading(TBTNode node) {
        if (node == null)
            return;

        inThreading(node.lChild);   // 对左子树进行线索化

        if (node.lChild == null) {
            node.lChild = this.pre;
            node.lTag = 1;
        }

        if (this.pre != null && this.pre.rChild == null) {
            this.pre.rChild = node;
            this.pre.rTag = 1;
        }

        this.pre = node;    // 改变线索二叉树pre的指向，便于下一结点的线索化！！
        inThreading(node.rChild);   // 对右子树进行线索化
    }

    public ThreadBTree(TBTNode root) {
        this.root = root;
    }
}

// 线索二叉树的结点类
class TBTNode {
    public int val;
    public TBTNode lChild;
    public TBTNode rChild;
    public int lTag;    // 0表示lChild是左子树，1表示lChild是直接前驱
    public int rTag;    // 0表示rChild是右子树，1表示rChild是直接后继

    @Override
    public String toString() {
        return "TBTNode{" +
                "val=" + val +
                '}';
    }

    public TBTNode(int val) {
        this.val = val;
    }
}
```

## 赫夫曼树

### 赫夫曼树的创建

```
public class HuffmanTreeDemo {
    public static void main(String[] args) {
        int[] arr = {7, 5, 2, 4};
        BTNode huffman = createHuffmanTree(arr);
        huffman.preOrder();
    }

    /**
     * 构建赫夫曼树
     * @param arr 用于构建赫夫曼树的序列
     * @return 构建好的赫夫曼树
     */
    private static BTNode createHuffmanTree(int[] arr) {
        if (arr == null || arr.length == 0)
            return null;

        // 将arr[]中的值都创建成BTNode结点后，为了方便操作，将其存入集合中
        ArrayList<BTNode> nodes = new ArrayList<>();
        for (int val : arr)
            nodes.add(new BTNode(val));

        while (nodes.size() > 1) {
            // 排序，每次取出最小的两个结点，并合成新结点
            Collections.sort(nodes);    // 利用Collections工具类进行排序
            BTNode n1 = nodes.remove(0);
            BTNode n2 = nodes.remove(0);

            int newVal = n1.val + n2.val;
            BTNode n = new BTNode(newVal);
            n.lChild = n1;
            n.rChild = n2;

            nodes.add(n);   // 将合并后的结点添加回集合中
        }

        return nodes.remove(0); // 最终集合中所剩下的BTNode就是赫夫曼树的根节点
    }
}

// 二叉树结点类，为了可以排序，让其实现Comparable接口
class BTNode implements Comparable<BTNode> {
    public int val;
    public BTNode lChild;
    public BTNode rChild;

    public BTNode(int val) {
        this.val = val;
    }

    /**
     * 前序遍历
     */
    public void preOrder() {
        System.out.print(this + "\t");
        if (this.lChild != null)
            this.lChild.preOrder();
        if (this.rChild != null)
            this.rChild.preOrder();
    }

    @Override
    public String toString() {
        return "BTNode{" +
                "val=" + val +
                '}';
    }

    @Override
    public int compareTo(BTNode o) {
        return this.val - o.val;
    }
}

```

### 赫夫曼编码和解码（数据压缩和解压缩）

- 如果文件本身就是经过压缩处理的（如视频、PPT等文件），再使用赫夫曼编码进行压缩没有意义，文件反而可能增大（因为还要存赫夫曼编码表）
- 如果文件中重复的内容不多，则使用赫夫曼编码进行压缩也没有意义

```
public class HuffmanCodeDemo {
    public static void main(String[] args) {
//        String str = "i like like like java do you like a java";
//        System.out.println("原始数据：" + str);
//
//        byte[] bytes = str.getBytes();
//        byte[] compressedBytes = huffmanZip(bytes);
//        System.out.println("原始数据字节：" + Arrays.toString(bytes));
//        System.out.println("数据压缩后字节：" + Arrays.toString(compressedBytes));
//
//        byte[] sourceBytes = decode(codeMap, compressedBytes);
//        System.out.println("解码后的数据：" + new String(sourceBytes));

        String zipSrc = "D:\\IDEA\\IdeaProject\\MyProject2\\myTest\\zipTest.txt";
        String zipDes = "D:\\IDEA\\IdeaProject\\MyProject2\\myTest\\zipTest.myZip";
        fileZip(zipSrc, zipDes);

        String unzipSrc = zipDes;
        String unzipDes = "D:\\IDEA\\IdeaProject\\MyProject2\\myTest\\unzipTest.txt";
        fileUnzip(unzipSrc, unzipDes);
    }

    /**
     * 对利用赫夫曼编码对文件进行无损压缩后的文件进行解压
     * @param zipPath 压缩文件位置
     * @param desPath 解压后的目的文件位置
     */
    public static void fileUnzip(String zipPath, String desPath) {
        ObjectInputStream in = null;
        FileOutputStream out = null;
        try {
            in = new ObjectInputStream(new FileInputStream(zipPath));
            Map<Byte, String> huffmanCodeMap = (Map<Byte, String>) in.readObject(); // 读取编码表
            byte[] compressedBytes = (byte[]) in.readObject();  // 读取压缩后的字节数据

            byte[] bytes = decode(huffmanCodeMap, compressedBytes);// 解压缩

            out = new FileOutputStream(desPath);
            out.write(bytes);   // 将解压后的字节数据写入目的文件中
        } catch (IOException | ClassNotFoundException e) {
            System.out.println(e.getMessage());
        } finally {
            try {
                if (in != null)
                    in.close();
                if (out != null)
                    out.close();
            } catch (IOException e) {
                System.out.println(e.getMessage());
            }
        }
    }

    /**
     * 利用赫夫曼编码对文件进行无损压缩
     * @param srcPath 源文件位置
     * @param desPath 压缩后的目的文件位置
     */
    public static void fileZip(String srcPath, String desPath) {
        FileInputStream in = null;
        ObjectOutputStream out = null;  // 利用ObjectOutputStream写入，解压时较方便
        try {
            in = new FileInputStream(srcPath);
            byte[] bytes = new byte[in.available()];    // 创建和源文件大小相同的数组bytes[]
            in.read(bytes); // 将源文件读入bytes[]中

            byte[] compressedBytes = huffmanZip(bytes); // 利用赫夫曼编码进行压缩

            // 将编码表和数据写入文件，用writeObject()方法，便于解压时读取
            out = new ObjectOutputStream(new FileOutputStream(desPath));
            out.writeObject(codeMap);   // ！！将赫夫曼编码表写入目的文件中，否则无法解压！！
            out.writeObject(compressedBytes); // 将压缩后的字节数据写入目的文件中
        } catch (IOException e) {
            System.out.println(e.getMessage());
        } finally {
            try {
                if (in != null)
                    in.close();
                if (out != null)
                    out.close();
            } catch (IOException e) {
                System.out.println(e.getMessage());
            }
        }
    }

    /**
     * 赫夫曼解码过程
     * @param huffmanCodes 赫夫曼编码表
     * @param huffmanBytes 经过赫夫曼编码的数据
     * @return 赫夫曼解码后的数据
     */
    public static byte[] decode(Map<Byte, String> huffmanCodes, byte[] huffmanBytes) {
        // 反转赫夫曼编码表，变成赫夫曼解码表
        Map<String, Byte> huffmanDecodes = new HashMap<>();
        for (Map.Entry<Byte, String> me : huffmanCodes.entrySet())
            huffmanDecodes.put(me.getValue(), me.getKey());

        // 将赫夫曼编码得到的字节数据转换回二进制字符串形式
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < huffmanBytes.length; i++) {
            byte b = huffmanBytes[i];
            if (i != huffmanBytes.length - 1)   // 不是最后一位时需要补高位
                sb.append(byteToBinaryString(true, b));
            else
                sb.append(byteToBinaryString(false, b));
        }

        // 用字符串匹配赫夫曼解码表，得到解码后的数据
        List<Byte> list = new ArrayList<>();    // 用于存放解码得到的字节数据
        for (int i = 0; i < sb.length(); ) {
            int count = 1;
            while (i + count <= sb.length()) {
                Byte result = huffmanDecodes.get(sb.substring(i, i + count));
                if (result != null) {   // 解码到数据，添加到list中，并将i后移
                    list.add(result);
                    i += count;
                    break;
                } else  // 未解码到数据，增加一位继续进行匹配
                    ++count;
            }
        }

        // 将list中存放的结果放入byte[]中并返回
        byte[] bytes = new byte[list.size()];
        for (int i = 0; i < list.size(); ++i)
            bytes[i] = list.get(i);

        return bytes;
    }

    /**
     * 将字节数据转换成二进制字符串形式
     * @param flag 是否需要补高位
     * @param b 字节数据
     * @return b对应的二进制字符串形式（注意是按补码的方式返回）
     */
    public static String byteToBinaryString(boolean flag, byte b) {
        // Byte没有toBinaryString()方法，要用Integer的方法来转换
        int temp = b;   // 将byte类型的b转换成int类型
        if (flag)
            temp |= 256;    // 补高位
        String str = Integer.toBinaryString(temp);  // 返回的是temp对应的二进制的补码
        if (flag)
            return str.substring(str.length() - 8); // 若补了高位，则截取低8位
        else
            return str;
    }

    /**
     * 通过赫夫曼编码，压缩数据
     * @param bytes 原始数据的字节数组
     * @return 数据压缩后的字节数组
     */
    public static byte[] huffmanZip(byte[] bytes) {
        // 创建赫夫曼树
        List<HuffmanNode> list = getNodes(bytes);
        HuffmanTree ht = createHuffmanTree(list);
//        ht.preOrder();

        // 利用赫夫曼树，得到赫夫曼编码表
        Map<Byte, String> huffmanCodes = getHuffmanCodes(ht);
//        System.out.println("赫夫曼编码表为：" + huffmanCodes);

        return getCompressedBytes(bytes, huffmanCodes);
    }

    /**
     * 通过赫夫曼编码表，压缩原始数据对应的字节数组
     * @param bytes 原始数据对应的字节数组
     * @param codes 赫夫曼编码表
     * @return 压缩后的字节数组
     */
    private static byte[] getCompressedBytes(byte[] bytes, Map<Byte, String> codes) {
        // 用StringBuilder存储压缩后的编码
        StringBuilder sb = new StringBuilder();
        for (byte data : bytes)
            sb.append(codes.get(data));
//        System.out.println(sb.toString());

        // 将压缩后的编码每8个一组转换成字节
        int len = (sb.length() + 7) / 8;    // len为需要的字节数（若是8的整数倍，则直接除以8，否则除以8后要加1）
        byte[] compressedBytes = new byte[len];
        for (int i = 0, index = 0; i < sb.length(); i += 8, ++index) {
            // 若有8位，则取8位；若不足8位，则取到最后
            String str;
            if (i + 8 < sb.length())
                str = sb.substring(i, i + 8);
            else
                str = sb.substring(i);

            /* 这两种方法不行，会抛出异常，应该是JDK不完善，不能识别符号位，所以只能用Integer的方法来转换
            compressedBytes[index] = Byte.parseByte(str, 2);
            compressedBytes[index] = Byte.valueOf(str, 2);
             */
            compressedBytes[index] = Integer.valueOf(str, 2).byteValue();
//            compressedBytes[index] = (byte)Integer.parseInt(str, 2);  // 这种方法也可以
        }

        return compressedBytes;
    }

    // 赫夫曼编码表，作为静态变量
    static Map<Byte, String> codeMap = new HashMap<>();

    /**
     * 通过赫夫曼树，生成赫夫曼编码
     * @param ht 赫夫曼树
     * @return 存储着赫夫曼编码的Map
     */
    private static Map<Byte, String> getHuffmanCodes(HuffmanTree ht) {
        if (ht == null)
            return null;

        getHuffmanCodes(ht.root, "", new StringBuilder());  // 从根结点开始编码，根结点无双亲结点，故code=""
        return codeMap;
    }

    /**
     * 生成赫夫曼编码的过程
     * @param node 当前结点
     * @param code 从双亲结点到当前结点要添加的编码（若是双亲结点的左子树，则添加"0"，若是双亲结点的右子树，则添加"1"）
     * @param sb1 双亲结点的编码
     */
    private static void getHuffmanCodes(HuffmanNode node, String code, StringBuilder sb1) {
        // ！！注意：不能直接用sb1，因为StringBuilder是引用型变量，形参和实参指向同一对象！！
        // 改变形参指向的对象时实参指向的对象也改变
        // 若直接用sb1，比如某结点左子树中sb1.append("0")，到右子树时sb1中指向的对象也已append("0")，造成错误
        StringBuilder sb2 = new StringBuilder(sb1);
        sb2.append(code);

        if (node.data == null) {    // node是非叶子结点，继续向子树进行编码
            if (node.lChild != null)
                getHuffmanCodes(node.lChild, "0", sb2);
            if (node.rChild != null)
                getHuffmanCodes(node.rChild, "1", sb2);
        } else    // node是叶子结点，将结点信息和编码存入静态变量codeMap中
            codeMap.put(node.data, sb2.toString());
    }

    /**
     * 创建赫夫曼树
     * @param list 存储着赫夫曼树叶子结点的List
     * @return 赫夫曼树
     */
    private static HuffmanTree createHuffmanTree(List<HuffmanNode> list) {
        if (list == null)
            return null;

        while (list.size() > 1) {
            Collections.sort(list);

            HuffmanNode n1 = list.remove(0);
            HuffmanNode n2 = list.remove(0);

            int weight = n1.weight + n2.weight;
            HuffmanNode parent = new HuffmanNode(weight);
            parent.lChild = n1;
            parent.rChild = n2;

            list.add(parent);
        }

        HuffmanNode root = list.remove(0);
        return new HuffmanTree(root);
    }

    /**
     * 统计数据中不同字节出现的次数，并创建好HuffmanNode，存储在List中返回
     * @param bytes 数据字节数组
     * @return 存储着赫夫曼树叶子结点的List
     */
    private static List<HuffmanNode> getNodes(byte[] bytes) {
        // 利用Map对不同字节出现的次数进行统计
        Map<Byte, Integer> map = new HashMap<>();
        for (Byte b : bytes) {
            Integer count = map.get(b);
            if (count == null)
                map.put(b,1);
            else {
                ++count;
                map.put(b, count);
            }
        }

        List<HuffmanNode> nodes = new LinkedList<>();

        // 将Map中的键值对逐个取出，并创建HuffmanNode，添加到nodes中
        Set<Map.Entry<Byte, Integer>> es = map.entrySet();
        for (Map.Entry<Byte, Integer> me : es) {
            Byte data = me.getKey();
            Integer count = me.getValue();
            nodes.add(new HuffmanNode(data, count));
        }

        return nodes;
    }
}

// 赫夫曼树类
class HuffmanTree {
    public HuffmanNode root;

    /**
     * 前序遍历赫夫曼树
     */
    public void preOrder() {
        this.root.preOrder();
    }

    public HuffmanTree(HuffmanNode root) {
        this.root = root;
    }
}

// 赫夫曼树的结点类，为了比较权重大小，使其实现Comparable接口
class HuffmanNode implements Comparable<HuffmanNode> {
    public Byte data;
    public int weight;
    public HuffmanNode lChild;
    public HuffmanNode rChild;

    /**
     * 前序遍历
     */
    public void preOrder() {
        System.out.println(this);

        if (this.lChild != null)
            this.lChild.preOrder();
        if (this.rChild != null)
            this.rChild.preOrder();
    }

    public HuffmanNode(Byte data, int weight) {
        this.data = data;
        this.weight = weight;
    }

    public HuffmanNode(int weight) {
        this.weight = weight;
    }

    @Override
    public String toString() {
        return "HuffmanNode{" +
                "data=" + data +
                ", weight=" + weight +
                '}';
    }

    @Override
    public int compareTo(HuffmanNode o) {
        return this.weight - o.weight;
    }
}
```

## 二叉排序树（BST）

- 二叉排序树的创建、遍历、添加结点、删除结点
 - 删除结点需要在其双亲结点上操作，可以在结点中增加一个parent，记录其双亲结点
 - 也可以查找两次，先查找待删除结点，再查找其双亲结点
 - 这里采用另一种方法，不设置parent属性，且同时查找，但根结点需要特别处理

```
public class BinarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = {7, 3, 10, 12, 5, 1, 9};

        BSTree bst = createBSTree(arr);
        bst.inOrder();
        System.out.println();

        int key = 11;
        bst.addNode(key);
        System.out.println("添加[" + key + "]：");
        bst.inOrder();
        System.out.println();

        key = 7;
        bst.deleteNode(key);
        System.out.println("删除[" + key +  "]：");
        bst.inOrder();
        System.out.println();
    }

    /**
     * 创建二叉排序树
     * @param arr 数据
     * @return 二叉排序树
     */
    private static BSTree createBSTree(int[] arr) {
        BSTree bst = new BSTree();
        for (int value : arr)
            bst.addNode(new BSTNode(value));
        return bst;
    }
}

// 二叉排序树类
class BSTree {
    public BSTNode root;

    /**
     * 二叉排序树删除结点
     *  根结点需要特殊处理
     * @param val 待删除结点的关键字值
     */
    public void deleteNode(int val) {
        if (this.root == null) {
            System.out.print("树为空");
            return;
        }

        if (val < this.root.val) {
            if (this.root.lChild != null)
                this.root.lChild.deleteNode(this.root, true, val);
            else
                System.out.println("未找到该结点");
        } else if (val > this.root.val) {
            if (this.root.rChild != null)
                this.root.rChild.deleteNode(this.root, false, val);
            else
                System.out.println("未找到该结点");
        } else {    // 根结点就是待删除结点，需要特别处理
            if (this.root.lChild == null && this.root.rChild == null) { // 若该树只有根结点，则将该树置空
                this.root = null;
                return;
            }
            BSTNode node;   // 用于找到新的根结点
            if (this.root.lChild != null) { // 左子树不为空时，找到左子树的最右下结点
                node = this.root.lChild;
                while (node.rChild != null)
                    node = node.rChild;
                this.root.val = node.val;   // 将node的val赋给root
                this.root.lChild.deleteNode(this.root, true, node.val);    // 在root的左子树上删除结点node
            } else {    // 左子树为空时，找到右子树的最左下结点
                node = this.root.rChild;
                while (node.lChild != null)
                    node = node.lChild;
                this.root.val = node.val;   // 将node的val赋给root
                this.root.rChild.deleteNode(this.root, false, node.val);    // 在root的右子树上删除结点node
            }
        }
    }

    /**
     * 二叉排序树添加结点
     * @param newNode 待添加结点
     */
    public void addNode(BSTNode newNode) {
        if (this.root == null)
            this.root = newNode;
        else
            this.root.addNode(newNode);
    }

    /**
     * 二叉排序树添加结点（不添加重复结点）
     * @param val 待添加结点的val值
     */
    public void addNode(int val) {
        this.root.addNode(new BSTNode(val));
    }


    /**
     * 中序遍历二叉排序树
     */
    public void inOrder() {
        if (this.root == null) {
            System.out.println("树为空");
            return;
        }
        this.root.inOrder();
    }
}

// 二叉排序树的结点类
class BSTNode {
    public int val;
    public BSTNode lChild;
    public BSTNode rChild;

    /**
     * 删除结点
     *  1. 待删除结点无子树，直接删除
     *  2. 待删除结点只有左子树或只有右子树，其左子树或右子树作为其双亲结点的新子树
     *  3. 待删除结点既有左子树又有右子树，找到其左子树的最右下结点，取代其位置，并在其左子树上删除该结点
     *  其中1和2可合并成一种情况
     * @param parent 当前结点的双亲结点
     * @param isLeft true-当前结点是parent的左子树 false-当前结点是parent的右子树
     * @param val 待删除结点的关键字
     */
    public void deleteNode(BSTNode parent, boolean isLeft, int val) {
        if (val < this.val) {
            if (this.lChild != null)
                this.lChild.deleteNode(this, true, val);
            else
                System.out.println("未找到该结点");
        } else if (val > this.val) {
            if (this.rChild != null)
                this.rChild.deleteNode(this, false, val);
            else
                System.out.println("未找到该结点");
        } else {    // 该结点就是待删除结点
            if (this.lChild == null || this.rChild == null) {   // 待删除结点只有左子树或只有右子树或没有子树
                if (isLeft) {   // 待删除结点是其双亲结点的左子树
                    if (this.lChild != null)
                        parent.lChild = this.lChild;
                    else
                        parent.lChild = this.rChild;
                } else {    // 待删除结点是其双亲结点的右子树
                    if (this.lChild != null)
                        parent.rChild = this.lChild;
                    else
                        parent.rChild = this.rChild;
                }
            } else {    // 待删除结点既有左子树又有右子树
                BSTNode node = this.lChild; // node用于找到左子树的最右下结点
                while (node.rChild != null)
                    node = node.rChild;
                this.val = node.val;    // 将node的val赋给本结点
                this.lChild.deleteNode(this, true, node.val);   // 在左子树上删除node
            }
        }

    }

    /**
     * 添加结点（重复结点不再添加）
     * @param newNode 要添加的结点
     */
    public void addNode(BSTNode newNode) {
        if (newNode.val < this.val) {
            if (this.lChild == null)
                this.lChild = newNode;
            else
                this.lChild.addNode(newNode);
        } else if (newNode.val > this.val) {
            if (this.rChild == null)
                this.rChild = newNode;
            else
                this.rChild.addNode(newNode);
        } else
            System.out.println("该结点已存在");
    }

    /**
     * 中序遍历
     */
    public void inOrder() {
        if (this.lChild != null)
            this.lChild.inOrder();
        System.out.print(this + " ");
        if (this.rChild != null)
            this.rChild.inOrder();
    }

    @Override
    public String toString() {
        return "BSTNode{" +
                "val=" + val +
                '}';
    }

    public BSTNode(int val) {
        this.val = val;
    }
}
```

## 平衡二叉树（AVL树）

- 左旋转：
 1. 创建一个新结点newNode，值为当前结点的值
 2. newNode的左子树设置为当前结点的左子树
 3. newNode的右子树设置为当前结点的右子树的左子树
 4. 当前结点的值设置为当前结点的右子树的值
 4. 当前结点的左子树设置为newNode
 5. 当前结点的右子树设置为当前结点的右子树的右子树
- 右旋转：
 1. 创建一个新结点newNode，值为当前结点的值
 1. newNode的右子树设置为当前结点的右子树
 1. newNode的左子树设置为当前结点的左子树的右子树
 1. 当前结点的值设置为当前结点的左子树的值
 1. 当前结点的右子树设置为newNode
 1. 当前结点的左子树设置为当前结点的左子树的左子树
- 每次添加结点时，检查是否满足平衡二叉树，如果不满足则调整
 1. 若 **rightHeight() - leftHeight() > 1**，需要**左旋转**，以降低右子树高度
 但**左旋前要先判断其右子树是否需要右旋**（若 **rChild.leftHeight() > rChild.rightHeight()**，**右子树需要右旋转**）
 因为左旋时要把当前结点右子树的左子树挂到当前结点左子树的右子树上，若挂的太长，还是无法平衡
 2. 若 **leftHeight() - rightHeight() > 1**，需要**右旋转**，以降低左子树高度
 但**右旋前要先判断其左子树是否需要左旋**（若 **lChild.rightHeight() > lChild.leftHeight()**，**左子树需要左旋**）
 因为右旋时要把当前结点左子树的右子树挂到当前结点右子树的左子树上，若挂的太长，还是无法平衡

```
public class AVLTreeDemo {
    public static void main(String[] args) {
//        int[] arr = {4, 3, 6, 5, 7, 8};
//        int[] arr = {10, 12, 8, 9, 7, 6};
//        int[] arr = {10, 11, 7, 6, 8, 9};
        int[] arr = {2, 1, 6, 5, 7, 3};
        AVLTree avl = createAVLTree(arr);
        System.out.println("树高度：" + avl.height());
        System.out.println("左子树高度：" + avl.root.leftHeight());
        System.out.println("右子树高度：" + avl.root.rightHeight());
        System.out.println("根结点" + avl.root);
    }

    private static AVLTree createAVLTree(int[] arr) {
        AVLTree tree = new AVLTree();
        for (int i = 0; i < arr.length; ++i)
            tree.addNode(arr[i]);
        return tree;
    }
}

// 平衡二叉树类
class AVLTree {
    public AVLNode root;

    /**
     * 求树的高度
     * @return 树的高度
     */
    public int height() {
        if (this.root == null)
            return 0;
        return this.root.height();
    }

    /**
     * 平衡二叉树添加结点
     * @param val 待添加结点的关键字值
     */
    public void addNode(int val) {
        AVLNode newNode = new AVLNode(val);
        if (this.root == null) {
            this.root = newNode;
            return;
        }
        this.root.addNode(val);
    }

    /**
     * 中序遍历平衡二叉树
     */
    public void inOrder() {
        if (this.root == null) {
            System.out.println("树为空");
            return;
        }
        this.root.inOrder();
    }

    public AVLTree(AVLNode root) {
        this.root = root;
    }

    public AVLTree() {
    }
}

// 平衡二叉树的结点类
class AVLNode {
    public int val;
    public AVLNode lChild;
    public AVLNode rChild;

    /**
     * 右旋转
     *  创建一个新结点newNode，值为当前结点的值
     *  newNode的右子树设置为当前结点的右子树
     *  newNode的左子树设置为当前结点的左子树的右子树
     *  当前结点的值设置为当前结点的左子树的值
     *  当前结点的右子树设置为newNode
     *  当前结点的左子树设置为当前结点的左子树的左子树
     */
    public void rightRotate() {
        AVLNode newNode = new AVLNode(this.val);
        newNode.rChild = this.rChild;
        newNode.lChild = this.lChild.rChild;
        this.val = this.lChild.val;
        this.rChild = newNode;
        this.lChild = this.lChild.lChild;
    }

    /**
     * 左旋转
     *  创建一个新结点newNode，值为当前结点的值
     *  newNode的左子树设置为当前结点的左子树
     *  newNode的右子树设置为当前结点的右子树的左子树
     *  当前结点的值设置为当前结点的右子树的值
     *  当前结点的左子树设置为newNode
     *  当前结点的右子树设置为当前结点的右子树的右子树
     */
    public void leftRotate() {
        AVLNode newNode = new AVLNode(this.val);
        newNode.lChild = this.lChild;
        newNode.rChild = this.rChild.lChild;
        this.val = this.rChild.val;
        this.lChild = newNode;
        this.rChild = this.rChild.rChild;
    }

    /**
     * 右子树高度
     * @return 右子树高度
     */
    public int rightHeight() {
        return this.rChild == null ? 0 : this.rChild.height();
    }

    /**
     * 左子树高度
     * @return 左子树高度
     */
    public int leftHeight() {
        return this.lChild == null ? 0 : this.lChild.height();
    }

    /**
     * 结点高度
     * @return 当前结点的高度
     */
    public int height() {
        return 1 + Math.max(this.lChild == null ? 0 : this.lChild.height(), this.rChild == null ? 0 : this.rChild.height());
    }

    /**
     * 添加结点（不添加重复结点）
     * @param val 待添加结点的关键字值
     */
    public void addNode(int val) {
        AVLNode newNode = new AVLNode(val);
        if (val < this.val) {
            if (this.lChild == null)
                this.lChild = newNode;
            else
                this.lChild.addNode(val);
        } else if (val > this.val) {
            if (this.rChild == null)
                this.rChild = newNode;
            else
                this.rChild.addNode(val);
        } else {
            System.out.println("该结点已存在，无法添加");
            return;
        }

        // 每次添加结点时，检查是否满足平衡二叉树，如果不满足则调整
        // 1. 若 rightHeight() - leftHeight() > 1，需要左旋，以降低右子树高度
        //    但左旋前要先判断其右子树是否需要右旋（若 rChild.leftHeight() > rChild.rightHeight()，右子树需要右旋）
        //    因为左旋时要把当前结点右子树的左子树挂到当前结点左子树的右子树上，若挂的太长，还是无法平衡
        // 2. 若 leftHeight() - rightHeight() > 1，需要右旋，以降低左子树高度
        //    但右旋前要先判断其左子树是否需要左旋（若 lChild.rightHeight() > lChild.leftHeight()，左子树需要左旋）
        //    因为右旋时要把当前结点左子树的右子树挂到当前结点右子树的左子树上，若挂的太长，还是无法平衡
        if (this.rightHeight() - this.leftHeight() > 1) {
            if (this.rChild.leftHeight() > this.rChild.rightHeight())
                this.rChild.rightRotate();
            this.leftRotate();
        } else if (this.leftHeight() - this.rightHeight() > 1) {
            if (this.lChild.rightHeight() > this.lChild.leftHeight())
                this.lChild.leftRotate();
            this.rightRotate();
        }
    }

    /**
     * 中序遍历
     */
    public void inOrder() {
        if (this.lChild != null)
            this.lChild.inOrder();
        System.out.print(this + " ");
        if (this.rChild != null)
            this.rChild.inOrder();
    }

    @Override
    public String toString() {
        return "AVLNode{" +
                "val=" + val +
                '}';
    }

    public AVLNode(int val) {
        this.val = val;
    }
}
```

## B树（B-树）、B+树、B*树

- B树（B-树）、B+树、B*树都是多路查找树
- 二叉树存在的问题：数据多时，构建二叉树需要的I/O操作次数太多，且二叉树高度太大，索引速度慢

### B树（B-树）

- B树的阶：结点的最大子结点个数
- **结点的子结点个数 = 该结点关键字个数 + 1**
- B树的关键字分布在整棵树中，即**叶子结点和非叶子结点都存放数据**
- 搜索有可能在非叶子结点结束
- 搜索性能等价于在关键字全集中做二分查找

![](.\MyPic\B-Tree.png)

### B+树

- B+树是B树的变体
- **结点的子结点个数 = 该结点关键字个数**
- B+树所有关键字都在叶子结点的**链表**中，即**只有叶子结点存放数据**
- 搜索不可能在非叶子结点结束
- 非叶子结点只作为叶子结点的索引
- B+树更适合文件索引系统

![](.\MyPic\B+Tree.png)

### B*树

- B*树是B+树的变体，在B+树的非叶子结点之间增加指向兄弟的指针

![](.\MyPic\B++Tree.png)

# 图

- 要描述多对多的关系时，需要用到图

## 深度优先遍历和广度优先遍历

```
public class MGraph {
    public static void main(String[] args) {
        String[] vertexes = {"1", "2", "3", "4", "5", "6", "7", "8"};
        MGraph mGraph = new MGraph(vertexes.length);
        for (String vertex : vertexes)
            mGraph.addVertex(vertex);
        mGraph.addEdge(0,1,1);
        mGraph.addEdge(0,2,1);
        mGraph.addEdge(1,3,1);
        mGraph.addEdge(1,4,1);
        mGraph.addEdge(2,5,1);
        mGraph.addEdge(2,6,1);
        mGraph.addEdge(3,7,1);
        mGraph.addEdge(4,7,1);
        mGraph.addEdge(5,6,1);

        System.out.println("邻接矩阵：");
        mGraph.showEdges();

        System.out.println("深度优先遍历：");
        mGraph.dfs();
        System.out.println();

        System.out.println("广度优先遍历：");
        mGraph.bfs();
        System.out.println();
    }

    public ArrayList<String> vertexList;   // 用于存储结点的ArrayList
    public int[][] edges;  // 邻接矩阵
    public int n;  // 顶点个数
    public int e;  // 边的条数

    /**
     * 广度优先遍历
     */
    public void bfs() {
        LinkedList<Integer> queue = new LinkedList<>(); // 作为队列使用
        int[] visited = new int[this.n];    // 用于记录每个顶点是否被访问过

        queue.addLast(0);
        while (queue.size() > 0) {
            // 从队列中取出一个顶点，若未被访问过，则开始遍历该顶点
            int index = queue.removeFirst();
            if (visited[index] == 0) {
                // 将该顶点所有未被访问过的邻接顶点入队
                for (int i = 0; i < this.n; ++i) {
                    if (this.edges[index][i] > 0 && visited[i] == 0)
                        queue.addLast(i);
                }
                // 访问该顶点
                visited[index] = 1;
                System.out.print(this.getVertex(index) + " ");
            }
        }
    }

    /**
     * 深度优先遍历
     */
    public void dfs() {
        int[] visited = new int[this.n];    // 用于记录每个顶点是否被访问过
        dfs(0, visited);
    }

    /**
     * 深度优先遍历
     * @param index 遍历的顶点下标
     * @param visited 记录顶点是否被访问过的数组 0-未访问过 1-已访问过
     */
    public void dfs(int index, int[] visited) {
        if (visited[index] == 1)
            return;

        visited[index] = 1;
        System.out.print(this.getVertex(index) + " ");

        for (int i = 0; i < this.n; ++i) {
            if (this.edges[index][i] > 0)
                dfs(i, visited);
        }
    }

    /**
     * 显示邻接矩阵的信息
     */
    public void showEdges() {
        for (int[] rows : this.edges) {
            for (int weight : rows)
                System.out.print(weight + "\t");
            System.out.println();
        }
    }

    /**
     * 获取连接两个顶点的边的权值
     * @param v1 边连接的顶点1
     * @param v2 边连接的顶点2
     * @return 两个顶点间的边的权值
     */
    public int getWeight(int v1, int v2) {
        if (v1 < 0 || v1 >= this.n || v2 < 0 || v2 >= this.n || v1 == v2) {
            System.out.println("数据错误");
            return -1;
        }
        return this.edges[v1][v2];
    }

    /**
     * 通过索引获取顶点信息
     * @param index 要获取的顶点的索引
     * @return 该顶点信息
     */
    public String getVertex(int index) {
        if (index < 0 || index >= n) {
            System.out.println("数据错误");
            return null;
        }
        return vertexList.get(index);
    }

    /**
     * 添加边
     * @param v1 边连接的顶点下标1
     * @param v2 边连接的顶点下标2
     * @param weight 边的权值
     */
    public void addEdge(int v1, int v2, int weight) {
        if (v1 < 0 || v1 >= this.n || v2 < 0 || v2 >= this.n || v1 == v2) {
            System.out.println("数据错误");
            return;
        }
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        ++this.e;
    }

    /**
     * 添加顶点
     * @param vertex 待添加顶点
     */
    public void addVertex(String vertex) {
        vertexList.add(vertex);
        ++this.n;
    }

    public MGraph(int n) {
        vertexList = new ArrayList<>(n);
        edges = new int[n][n];
    }
}
```

# 分治算法

- 分而治之
- 将复杂问题分解为可以求解的小问题，若分解后仍不能求解，则继续分解

## 汉诺塔问题

```
public class HanoiTowerDemo {
    public static void main(String[] args) {
        move(5,'a', 'b', 'c');
    }

    /**
     * 在汉诺塔上移动圆盘（将a塔上的num个圆盘移动到c塔，用b塔作为辅助）
     * @param num 要移动的圆盘个数
     * @param a 移动的起始塔
     * @param b 移动的辅助塔
     * @param c 移动的目标塔
     */
    private static void move(int num, char a, char b, char c) {
        if (num == 1) { // 只有一个圆盘时，直接从a塔移动到c塔
//            move(1, a, b, c);
            System.out.println("第1个圆盘：" + a + "->" + c);
            return;
        }

        move(num-1, a, c, b);   // 将a塔n个圆盘中的上面(n-1)个移动到b塔，用c塔作为辅助

//        move(1, a, b, c);   // 将a塔剩下的1个圆盘移动到c塔
        System.out.println("第" + num + "个圆盘：" + a + "->" + c);

        move(num-1, b, a, c);   // 将b塔上的(n-1)个圆盘移动到c塔，用a塔作为辅助
    }
}

```

# 动态规划算法（“选”和“不选”）

- 动态规划算法的核心思想：将大问题分解为小问题进行解决，从而一步步获得最优解
- 动态规划算法和分治算法类似，但其适用于动态规划求解的问题，即**经过分解后的子问题往往不是相互独立的**

## 背包问题

- 背包问题是指给定一个**定容量的背包**、若干具有一定价值和重量的物品，**如何选择物品放入背包使得背包内的物品价值最大**
- 背包问题可以分为**01背包问题**（每种物品只能放一件）和**完全背包问题**（每种物品可以放多件），而完全背包问题可以转化成01背包问题
- 利用填表法解决

```
 *                   weight[i] - 第i个物品的重量 weight[0] = 0
 *                   value[i] - 第i个物品的价值 value[0] = 0
 *                   v[i][j] - 前i个物品，选择总重量为j的物品放入背包时，能获得的最大价值 v[0][j] = v[i][0] = 0
 *
 *                   思路：
 *                   1. v[0][j] = v[i][0] = 0   // 填入表中的第1行和第1列都为0
 *
 *                   2. 若 weight[i] > j，则 v[i][j] = v[i-1][j]
 *                   // 当前新增物品的重量(weight[i])大于当前背包容量(j)，则直接使用之前得到的装入策略(v[i-1][j])
 *
 *                   3. 若 weight[i] <= j，则 v[i][j] = max{v[i-1][j], value[i] + v[i-1][j-weight[i]]}
 *                   // 当前新增物品的重量(weight[i])不大于当前背包容量(j)，则将新增物品装入(value[i])
 *                   // 在剩余空间(j-weight[i])中选择之前得到的最佳装入策略(v[i-1][j-weight[i]])装入(+)
 *                   // 然后再和前(i-1)个物品时的最佳装入策略(v[i-1][j])进行比较，选择较大价值者(max{})，即为新的装入策略
```

```
public class KnapsackDemo {
    public static void main(String[] args) {
        ArrayList<Item> list = new ArrayList<>();
        Item guitar = new Item("吉他", 1, 1500);
        Item audio = new Item("音响", 4, 3000);
        Item pc = new Item("电脑", 3, 2000);
        list.add(guitar);
        list.add(audio);
        list.add(pc);

        int itemNum = list.size();  // 物品种类数
        int capacity = 4;   // 背包的容量

        int[] weight = new int[itemNum + 1];    // weight[0] = 0, weight[i]表示第i个物品的重量
        int[] value = new int[itemNum + 1]; // value[0] = 0, value[i]表示第i个物品的价值
        int[][] v = new int[itemNum + 1][capacity + 1];  // v[0][j] = v[i][0] = 0, v[i][j]表示只考虑前i个物品，背包容量为j时，能装入的最大价值
        int[][] path = new int[itemNum + 1][capacity + 1];  // 用于记录放入的物品，path[i][j] = 1 表示当前背包剩余容量为j时，第i个物品被放入过背包（不一定是最后一次放入的）

        for (int i = 0; i < list.size(); i++) {
            weight[i+1] = list.get(i).weight;
            value[i+1] = list.get(i).value;
        }

        // 开始动态规划
        for (int i = 1; i < v.length; ++i) {
            for (int j = 1; j < v[0].length; ++j) {
                if (weight[i] > j)    // 若当前新增物品的重量(weight[i])大于当前背包容量(j)
                    v[i][j] = v[i - 1][j];    // 选择之前得到的最佳装入策略(v[i-1][j])
                else {    // 若当前新增物品的重量不大于当前背包容量，则将新增物品装入背包(value[i])，剩余空间采用之前的最佳装入策略(v[i-1][j-weight[i]])
                    v[i][j] = Math.max(v[i - 1][j], value[i] + v[i - 1][j - weight[i]]);  // 再与原最佳装入策略(v[i-1][j])比较，选择较大者
                    // 如果第i个物品放入背包，则记录
                    if (v[i - 1][j] < value[i] + v[i - 1][j - weight[i]])
                        path[i][j] = 1;
                }
            }
        }

        for (int[] rows : v) {
            for (int sum : rows)
                System.out.print(sum + " ");
            System.out.println();
        }

        // path[][]中保存的不只是最后一次的物品放入情况，应该从后往前遍历，还原最后一次放入的物品

        /* 直接输出path[][]，会有冗余的放入情况，不只是最后一次的放入情况
        for (int i = 0; i < path.length; ++i) {
            for (int j = 0; j < path[0].length; ++j) {
                if (path[i][j] == 1)
                    System.out.println("第" + i + "个物品放到背包中");
            }
        }
        */

        /*
        for (int[] rows : path) {
            for (int col : rows)
                System.out.print(col + " ");
            System.out.println();
        }
         */

        // 应该从后向前遍历，还原最后一次放入的物品
        // path[][]记录时是i从小到大记录的，因此path[i][j]从后向前遍历时第一次为1时，一定是最后一次放入的情况

        // i从大到小遍历，依次判断前一个物品是否放入背包
        for (int i = path.length - 1, rest = path[0].length - 1; i >= 0; --i) { // i表示第i个物品，rest表示背包剩余容量
            if (path[i][rest] == 1) {   // 第i个物品放入背包
                System.out.println("第" + i + "个物品(" + list.get(i-1).name + ")放入背包");
                rest -= weight[i];  // 背包剩余容量减少
            }
        }
    }
}

class Item {
    public String name;
    public int weight;
    public int value;

    public Item(String name, int weight, int value) {
        this.name = name;
        this.weight = weight;
        this.value = value;
    }
}
```

练习：从数组中选出几个数使其和最大，要求每两个数不能相邻
```
    /**
     * 从数组中选出几个数使其和最大，要求每两个数不能相邻
     */
    @Test
    public void dp1() {
        //        int[] arr = {1, 2, 4, 1, 7, 8, 3};
        int[] arr = {4, 1, 1, 9, 1};
        int[] opt = new int[arr.length];
        opt[0] = arr[0];
        opt[1] = Math.max(arr[0], arr[1]);

        for (int i = 2; i < opt.length; ++i) {
            opt[i] = Math.max(opt[i - 1], arr[i] + opt[i - 2]);
        }

//        System.out.println(Arrays.toString(opt));
        System.out.println(opt[opt.length - 1]);
    }
```

练习：数组（正整数）中是否存在子集，使得其和为给定数。如{3, 34, 4, 12, 5, 2}，要求和为9，存在
```
    /**
     * 数组（正整数）中是否存在子集，使得其和为给定数
     * 如{3, 34, 4, 12, 5, 2}，要求和为9，存在
     */
    @Test
    public void dp2() {
        int[] arr = {3, 34, 4, 12, 5, 2};
        int sum = 13;

        /* 递归
        System.out.println(rec_subset(arr, arr.length - 1, sum));   */

        // 非递归
        boolean[][] dp = new boolean[arr.length][sum + 1];  // dp[i][j]表示前(i+1)个数能不能组成j
        for (int i = 0; i < dp.length; ++i) // 一定能组成0（全都不选）
            dp[i][0] = true;
        for (int i = 1; i < dp[0].length; ++i)  // 第1个数字只能组成其本身（和0）
            dp[0][i] = (arr[0] == i);

        for (int i = 1; i < dp.length; ++i) {
            for (int j = 0; j < dp[0].length; ++j) {
                dp[i][j] = (dp[i - 1][j] || (j >= arr[i] && dp[i - 1][j - arr[i]]));
            }
        }

        System.out.println(dp[arr.length - 1][sum]);

//        for (boolean[] xx : dp)
//            System.out.println(Arrays.toString(xx));
    }

    private boolean rec_subset(int[] arr, int index, int sum) {
        if (index == 0)
            return arr[0] == sum;
        else if (arr[index] < sum)
            return (rec_subset(arr, index - 1, sum - arr[index])
                    || rec_subset(arr, index - 1, sum));
        else if (arr[index] == sum)
            return true;
        else
            return rec_subset(arr, index - 1, sum);
    }
}
```

# KMP算法

```

 *                  核心：最大公共前后缀
 *                        next[]数组的含义：当模式串在j位置发生不匹配时，应从next[j]的位置开始进行下一轮匹配
 *                        nextVal[]数组的求法：先求出next[]数组
 *                                             若 substr.charAt(i) == substr.charAt(next[i])，则 nextVal[i] = nextVal[next[i]]
 *                                             否则 nextVal[i] = next[i]
```

```
public class KMPDemo {
    public static void main(String[] args) {
        String str1 = "ABABCABCACBAB";
        String str2 = "ABCAC";

        int index = violenceMatch(str1, str2);  // 暴力匹配法
        System.out.println("index = " + index);

        index = kmp(str1, str2);    // KMP算法
        System.out.println("index = " + index);

        index = kmp2(str1, str2);   // 改进KMP算法
        System.out.println("index = " + index);
    }

    /**
     * 改进KMP算法
     * @param str 主串
     * @param substr 模式串
     * @return substr在str中的位置，未找到则返回-1
     */
    private static int kmp2(String str, String substr) {
        int[] nextVal = getNextVal(substr); // 获取模式串的nextVal[]数组
        int i = 0, j = 0;
        while (i < str.length() && j < substr.length()) {
            if (j == -1 || str.charAt(i) == substr.charAt(j)) {
                ++i;
                ++j;
            } else
                j = nextVal[j];
        }

        if (j >= substr.length())
            return i - substr.length();
        else
            return -1;
    }

    /**
     * 获取模式串的nextVal[]数组
     * @param substr 模式串
     * @return nextVal[]数组
     */
    private static int[] getNextVal(String substr) {
        int[] nextVal = new int[substr.length()];
        int i = 0, j = -1;  // i指向后缀，j指向前缀
        nextVal[0] = -1;    // nextVal[0]置为-1
        while (i < substr.length() - 1) {
            if (j == -1 || substr.charAt(i) == substr.charAt(j)) {
                ++i;
                ++j;
                /* 此时next[i] = j */
                if (substr.charAt(i) == substr.charAt(j))   // 即substr.charAt(i) == substr.charAt(next[i])
                    nextVal[i] = nextVal[j];    // 即nextVal[i] = nextVal[next[i]]
                else
                    nextVal[i] = j; // 即nextVal[i] = next[i]
            } else
                j = nextVal[j]; // 未匹配时，j回溯到nextVal[j]
        }
        return nextVal;
    }

    /**
     * KMP算法
     * @param str 主串
     * @param substr 模式串
     * @return substr在str中的位置，未找到则返回-1
     */
    private static int kmp(String str, String substr) {
        int[] next = getNext(substr);   // 获取模式串的next[]数组
        int i = 0, j = 0;   // i用于遍历主串，j用于遍历模式串
        while (i < str.length() && j < substr.length()) {
            if (j == -1 || str.charAt(i) == substr.charAt(j)) { // 当前元素匹配时，i和j都后移
                ++i;
                ++j;
            } else    // 当前元素不匹配时，j（模式串）回溯，从next[j]的位置开始下一轮匹配，而i（主串）不需要回溯
                j = next[j];
        }

        if (j >= substr.length())   // 找到匹配
            return i - substr.length();
        else    // 未找到匹配
            return -1;
    }

    /**
     * 获取模式串的next[]数组
     * @param substr 模式串
     * @return next[]数组
     */
    private static int[] getNext(String substr) {
        int[] next = new int[substr.length()];

        int i = 0, j = -1;  // i指向后缀，j指向前缀
        next[0] = -1;   // 将next[0]置为-1，因为j可能要回溯到next[0]的位置，此时要使j恢复到-1的位置

        while (i < substr.length() - 1) {
            if (j == -1 || substr.charAt(i) == substr.charAt(j)) {  // 匹配时，i和j都后移，并记录下next[i]的值
                ++i;
                ++j;
                next[i] = j;
            } else
                j = next[j];    // 未匹配时，j回溯到next[j]的位置
        }
        return next;
    }

    /**
     * 暴力匹配法
     * @param str 主串
     * @param substr 模式串
     * @return substr在str中的位置，未找到则返回-1
     */
    private static int violenceMatch(String str, String substr) {
        int i = 0, j = 0;
        while (i < str.length() && j < substr.length()) {
            if (str.charAt(i) == substr.charAt(j)) {
                ++i;
                ++j;
            } else {
                i = i - j + 1;
                j = 0;
            }
        }
        if (j >= substr.length())   // 匹配成功
            return i - substr.length();
        else    // 匹配失败
            return -1;
    }
}
```

# 贪婪算法

- 贪婪算法得到的解不一定是最优解（也可能是最优解），但都接近最优解

```
 *                  选择最少的广播电台，让所有地区都可以接收到信号
 *                  电台      覆盖地区
 *                  K1        北京 天津 上海
 *                  K2        广州 北京 深圳
 *                  K3        成都 上海 杭州
 *                  K4        上海 天津
 *                  K5        杭州 大连
 *
 *                  思路：每次选择能覆盖最多仍未覆盖区域的电台，并将其能覆盖的区域移除，直到所有区域都被覆盖
```

```
public class GreedyDemo {
    public static void main(String[] args) {
        // 保存电台及其覆盖地区
        Map<String, HashSet<String>> map = new HashMap<>();

        HashSet<String> areas1 = new HashSet<>();
        areas1.add("北京");
        areas1.add("天津");
        areas1.add("上海");

        HashSet<String> areas2 = new HashSet<>();
        areas2.add("广州");
        areas2.add("北京");
        areas2.add("深圳");

        HashSet<String> areas3 = new HashSet<>();
        areas3.add("成都");
        areas3.add("上海");
        areas3.add("杭州");

        HashSet<String> areas4 = new HashSet<>();
        areas4.add("上海");
        areas4.add("天津");

        HashSet<String> areas5 = new HashSet<>();
        areas5.add("杭州");
        areas5.add("大连");

        map.put("K1", areas1);
        map.put("K2", areas2);
        map.put("K3", areas3);
        map.put("K4", areas4);
        map.put("K5", areas5);

        // 用Set保存剩余未被覆盖区域
        HashSet<String> restAreas = new HashSet<>();    // 保存剩余未被覆盖的区域
        for (Map.Entry<String, HashSet<String>> me : map.entrySet()) {
            HashSet<String> areas = me.getValue();
            restAreas.addAll(areas);
        }

        // 每次选择能覆盖最多剩余未被覆盖区域的电台，添加到Set中，并将其所有覆盖区域从剩余未被覆盖区域中删除，直到覆盖所有区域
        HashSet<String> selects = new HashSet<>();  // 保存选中的电台
        while (!restAreas.isEmpty()) {
            String nextSelect = getMostRestAreas(map, restAreas); // 选出能覆盖最多未覆盖区域的电台
            restAreas.removeAll(map.get(nextSelect)); // 将该电台所能覆盖的区域从剩余区域中删除
            selects.add(nextSelect);  // 将该电台添加到selects中
        }

        System.out.println("选中的电台：" + selects);
    }

    /**
     * 从电台集合中选择能覆盖最多剩余未被覆盖区域的电台
     * @param map 存储着电台及其覆盖区域的Map
     * @param restAreas 存储着剩余未被覆盖区域的HashSet
     * @return 能覆盖最多剩余未被覆盖区域的电台，即要选择的电台
     */
    private static String getMostRestAreas(Map<String, HashSet<String>> map, HashSet<String> restAreas) {
        Map<String, Integer> tab = new HashMap<>(); // 保存电台及其能覆盖到的剩余未被覆盖区域的数量

        // 统计每个电台能覆盖的剩余未被覆盖区域的数量
        for (Map.Entry<String, HashSet<String>> me : map.entrySet()) {
            String audio = me.getKey();
            HashSet<String> areas = me.getValue();

            areas.retainAll(restAreas); // 该电台能覆盖的区域和剩余未被覆盖区域取交集，交集大小即为能覆盖的剩余未被覆盖区域数量
            tab.put(audio, areas.size());

            /* 也可以用计数器来统计能覆盖的剩余未被覆盖区域数量
            int count = 0;  // 记录每个电台能覆盖的剩余未被覆盖区域的数量
            for (String area : areas) {
                if (restAreas.contains(area))
                    ++count;
            }
            tab.put(audio, count);
             */
        }

        // 在tab中选择value最大的key，即为要选择的电台
        /* 利用List来取出Map中value最大值对应的key值 */
        List<Map.Entry<String, Integer>> list = new ArrayList<>(tab.entrySet());
        list.sort((o1, o2) -> o2.getValue() - o1.getValue());   // list中元素按value从大到小排序
        return list.get(0).getKey();
    }
}
```

# 最小生成树问题

- 针对有权无向图，如修路问题、公交站问题

以下两个算法用到的最小生成树类：
```
public class MST {
    public MGraph graph;

    public static final int INF = PrimDemo.INF; // 用INF表示不可达

    /**
     * 克鲁斯卡尔算法
     */
    public void kruskal() {
        int n = this.graph.n;   // 顶点个数

        int[] mfs = new int[n]; // 并查集，用于判断是否构成回路，mfs[i] = j 表示下标为i的顶点的"根"是下标为j的顶点
        for (int i = 0; i < n; ++i)
            mfs[i] = i; // 没有添加任何边时，所有顶点的"根"都是自己

        ArrayList<Edge> edgeList = new ArrayList<>();   // 将所有边的信息存储到ArrayList中，便于根据权值排序并取出
        for (int i = 0; i < n - 1; ++i) {
            for (int j = i + 1; j < n; ++j) {   // 每条边只存一次
                if (this.graph.edges[i][j] < INF)
                    edgeList.add(new Edge(i, j, this.graph.edges[i][j]));
            }
        }

        edgeList.sort(Comparator.comparingInt(e -> e.weight));   // 将边按权值从小到大排序
//        edgeList.sort((e1, e2) -> e1.weight - e2.weight);   // 也可以直接使用Lambda表达式

        int count = 0;
        while (count < n - 1) {    // 最小生成树需要(n-1)条边
            Edge edge = edgeList.remove(0); // 取出当前最短边
            int root1 = getRoot(edge.v1, mfs);
            int root2 = getRoot(edge.v2, mfs);
            if (root1 != root2) {   // 若该边的两个顶点的"根"不同，则不会构成回路，选择该条边
                System.out.println("选择边<" + this.graph.vertexList.get(edge.v1) + ","
                        + this.graph.vertexList.get(edge.v2) + ">，权值为" + edge.weight);
                mfs[root1] = mfs[root2];    // 连通后，将顶点1的"根"置为顶点2的"根"
                ++count;
            }
        }
    }

    /**
     * 利用并查集，获取顶点的"根"顶点
     * @param v 顶点
     * @param mfs 并查集，用于保存顶点的"根"，mfs[i] = j表示下标为i的顶点的"根"是下标为j的顶点
     * @return 顶点v的"根"顶点
     */
    private int getRoot(int v, int[] mfs) {
        while (v != mfs[v])
            v = mfs[v];
        return v;
    }

    // 边
    static class Edge {
        public int v1;  // 边的顶点1的下标
        public int v2;  // 边的顶点2的下标
        public int weight;  // 边的排序

        public Edge(int v1, int v2, int weight) {
            this.v1 = v1;
            this.v2 = v2;
            this.weight = weight;
        }
    }

    /**
     * 普利姆算法
     * @param v0 开始顶点
     */
    public void prim(int v0) {
        int n = this.graph.n;   // 顶点数
        int[] visited = new int[n]; // 记录每个顶点是否被访问过
        visited[v0] = 1;

        for (int k = 0; k < n - 1; ++k) {   // 最小生成树有(n-1)条边，因此循环(n-1)次
            // 每次循环找到一个已访问顶点到未访问顶点的最短边
            int minWeight = INF;    // 用于保存当前生成树到未访问结点的最短边的权值
            int v1 = -1, v2 = -1;   // v1、v2用于保存该最短边的两个顶点

            for (int i = 0; i < n; ++i) {   // i表示已访问顶点
                if (visited[i] == 0)
                    continue;

                for (int j = 0; j < n; ++j) {   // j表示未访问顶点
                    if (visited[j] == 0 && this.graph.edges[i][j] < minWeight) {
                        minWeight = this.graph.edges[i][j];
                        v1 = i;
                        v2 = j;
                    }
                }
            }
            System.out.println("选择边<" + this.graph.vertexList.get(v1) + ","
                    + this.graph.vertexList.get(v2) + ">，权值为" + minWeight);
            visited[v2] = 1;    // 将v2置为已访问过
        }
    }

    public MST(MGraph graph) {
        this.graph = graph;
    }

    // 用邻接矩阵表示的图
    static class MGraph {
        public ArrayList<String> vertexList;    // 用于存放顶点信息的ArrayList
        public int[][] edges;   // 邻接矩阵
        public int n;   // 顶点个数
        public int e;   // 边的条数

        public static final int INF = PrimDemo.INF;

        public MGraph(ArrayList<String> vertexList, int[][] edges) {
            this.vertexList = vertexList;
            this.edges = edges;
            this.n = vertexList.size();
            for (int[] rows : edges)
                for (int weight : rows)
                    if (weight < INF && weight != 0)
                        ++this.e;
        }
    }
}
```

## 普利姆(Prim)算法

```
 思想：从一个顶点开始，选择到未访问顶点的最短边，添加该边，再选择当前生成树到未访问顶点的最短边，直到所有顶点都被访问
```

```
public class PrimDemo {
    public static final int INF = Integer.MAX_VALUE;    // 用INF表示不可达

    public static void main(String[] args) {
        ArrayList<String> vertexes = new ArrayList<>(List.of("A", "B", "C", "D", "E", "F", "G"));
        int[][] edges = {
                {0, 5, 7, INF, INF, INF, 2},
                {5, 0, INF, 9, INF, INF, 3},
                {7, INF, 0, INF, 8, INF, INF},
                {INF, 9, INF, 0, INF, 4, INF},
                {INF, INF, 8, INF, 0, 5, 4},
                {INF, INF, INF, 4, 5, 0, 6},
                {2, 3, INF, INF, 4, 6, 0}};

        MST minTree = new MST(new MST.MGraph(vertexes, edges));
        minTree.prim(0);
    }
}
```

## 克鲁斯卡尔(Kruskal)算法

```
 思想：每次取最短边，并检查是否构成回路，若不构成回路则添加该条边
 	检查是否构成回路的方法：利用并查集，将每个顶点的"根"置为其当前生成树中的最大顶点
						 若某条边的两个顶点的"根"相同，则两个顶点已连通，此时放弃这条边，因为会构成回路
```

```
public class KruskalDemo {
    public static final int INF = Integer.MAX_VALUE;    // 用INF表示不可达

    public static void main(String[] args) {
        ArrayList<String> vertexes = new ArrayList<>(List.of("A", "B", "C", "D", "E", "F", "G"));
        int[][] edges = {
                {0, 12, INF, INF, INF, 16, 14},
                {12, 0, 10, INF, INF, 7, INF},
                {INF, 10, 0, 3, 5, 6, INF},
                {INF, INF, 3, 0, 4, INF, INF},
                {INF, INF, 5, 4, 0, 2, 8},
                {16, 7, 6, INF, 2, 0, 9},
                {14, INF, INF, INF, 8, 9, 0}};
        MST minTree = new MST(new MST.MGraph(vertexes, edges));
        minTree.kruskal();
    }
}
```

# 最短路径问题

- 可以是有向图

## 迪杰斯特拉(Dijkstra)算法

- 迪杰斯特拉算法用于计算**某个顶点到其他顶点**的最短路径

```
 * dis[] 记录开始顶点到各个顶点的最短距离，dis[i] = j 表示开始顶点v0到顶点vi的最短距离为j
 * path[] 记录开始顶点到各个顶点最短路径上的最后一个经过的顶点，path[i] = j 表示开始顶点v0到顶点vi的最短路径上的最后一个经过的顶点为顶点vj
 *                                  
 * 思想：从开始顶点开始，合并最近的未被访问过的顶点
 *      并用该顶点更新到其他未被访问顶点的最短距离dis[]和路径path[]
 *      再次合并最近的未被访问过的顶点，更新，直到所有顶点都被访问
```

```
public class DijkstraDemo {
    public static final int INF = Integer.MAX_VALUE;    // INF表示不可达

    public static void main(String[] args) {
        ArrayList<String> vertexes = new ArrayList<>(List.of("0", "1", "2", "3", "4", "5", "6"));
        int[][] edges = {
                {0, 4, 6, 6, INF, INF, INF},
                {INF, 0, 1, INF, 7, INF, INF},
                {INF, INF, 0, INF, 6, 4, INF},
                {INF, INF, 2, 0, INF, 5, INF},
                {INF, INF, INF, INF, 0, INF, 6},
                {INF, INF, INF, INF, 1, 0, 8},
                {INF, INF, INF, INF, INF, INF, 0}};
        MGraph graph = new MGraph(vertexes, edges);
        dijkstra(graph, 0);
    }

    /**
     * 迪杰斯特拉算法
     * @param graph 图
     * @param v0 开始顶点
     */
    private static void dijkstra(MGraph graph, int v0) {
        int n = graph.n;  // 顶点个数
        int[] visited = new int[n]; // 用于记录各个顶点是否被访问过
        int[] path = new int[n];    // 用于记录从v0到vi的最短路径上vi的前一个顶点
        int[] dis = new int[n]; // 用于记录v0到各个顶点的最短路径长度

        // 初始化visited[]、path[]和dis[]
        visited[v0] = 1;
        for (int i = 0; i < n; ++i) {
            if (v0 != i && graph.edges[v0][i] < INF)
                path[i] = v0;
            else
                path[i] = -1;
            dis[i] = graph.edges[v0][i];
        }

        for (int k = 0; k < n - 1; ++k) {   // 共要依次合并(n-1)个顶点
            // 在dis[]中找到最近的且未被访问过的顶点
            int nextSelect = -1;
            int minDis = INF;
            for (int i = 0; i < n; ++i) {
                if (visited[i] == 0 && dis[i] < minDis) {
                    nextSelect = i;
                    minDis = dis[i];
                }
            }
            // 将该顶点置为已访问，并用该顶点更新dis[]和path[]
            visited[nextSelect] = 1;
            for (int i = 0; i < n; ++i) {
                if (visited[i] == 0 && graph.edges[nextSelect][i] < INF
                        && dis[nextSelect] + graph.edges[nextSelect][i] < dis[i]) {
                    dis[i] = dis[nextSelect] + graph.edges[nextSelect][i];
                    path[i] = nextSelect;
                }
            }
        }


//        System.out.println("visited[]:" + Arrays.toString(visited));
//        System.out.println("dis[]:" + Arrays.toString(dis));
//        System.out.println("path[]:" + Arrays.toString(path));

        for (int i = 0; i < n; ++i) {
            if (i == v0)
                continue;

            if (dis[i] < INF)
                System.out.println(graph.vertexes.get(v0) + "到" + graph.vertexes.get(i) + "的最短路径长度是" + dis[i]
                + "，最短路径上的最后一个顶点是" + path[i]);
            else
                System.out.println(graph.vertexes.get(v0) + "到" + graph.vertexes.get(i) + "不可达");
        }
    }

    // 用邻接矩阵存储的图
    static class MGraph {
        public ArrayList<String> vertexes;  // 顶点信息
        public int[][] edges;   // 邻接矩阵
        public int n;   // 顶点个数
        public int e;   // 边的条数

        public MGraph(ArrayList<String> vertexes, int[][] edges) {
            this.vertexes = vertexes;
            this.edges = edges;
            this.n = vertexes.size();
            for (int[] rows : edges)
                for (int dis : rows)
                    if (dis < INF && dis > 0)
                        ++this.e;
        }
    }
}
```

## 弗洛伊德(Floyd)算法

- 弗洛伊德算法用于计算图中**各个顶点之间**的最短路径
- 思想：用每个顶点依次作为中间顶点来更新其他顶点之间的距离和路径，即更新dis[][]数组和path[][]数组

```
 * dis[][] 记录任意两个顶点之间的最短距离，dis[i][j] = k 表示顶点vi到顶点vj之间的最短距离为k
 * path[][] 记录任意两个顶点之间的最短路径上经过的最后一个顶点，path[i][j] = k 表示顶点vi到顶点vj之间的最短路径上经过的最后一个顶点为顶点vk
 *
 * 思想：用每个顶点依次作为中间顶点来更新其他顶点之间的距离和路径，即更新dis[][]和path[][]
```

```
public class FloydDemo {
    public static final int INF = Integer.MAX_VALUE;    // INF表示不可达

    public static void main(String[] args) {
        ArrayList<String> vertexes = new ArrayList<>(List.of("0", "1", "2", "3"));
        int[][] edges = {
                {0, 5, INF, 7},
                {INF, 0, 4, 2},
                {3, 3, 0, 2},
                {INF, INF, 1, 0}};
        MGraph graph = new MGraph(vertexes, edges);
        floyd(graph);
    }

    /**
     * 弗洛伊德算法
     * @param graph 图
     */
    private static void floyd(MGraph graph) {
        int n = graph.n;    // 顶点个数
        int[][] dis = new int[n][n];    // dis[i][j] = k 表示顶点vi到顶点vj的最短距离为k
        int[][] path = new int[n][n];   // path[i][j] = k 表示顶点vi到顶点vj的最短路径上vj的前一个顶点为顶点vk

        // 初始化dis[][]和path[][]
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                dis[i][j] = graph.edges[i][j];
                if (i != j && dis[i][j] < INF)
                    path[i][j] = i;
                else
                    path[i][j] = -1;
            }
        }

        for (int k = 0; k < n; ++k) {   // 将每个顶点作为中间顶点来更新dis[]和path[]
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (dis[i][k] < INF && dis[k][j] < INF && dis[i][k] + dis[k][j] < dis[i][j]) {
                        dis[i][j] = dis[i][k] + dis[k][j];
                        path[i][j] = k;
                    }
                }
            }
        }

//        System.out.println("dis[][]:");
//        for (int[] rows : dis)
//            System.out.println(Arrays.toString(rows));
//
//        System.out.println("path[][]:");
//        for (int[] rows : path)
//            System.out.println(Arrays.toString(rows));

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (i == j)
                    continue;

                if (dis[i][j] < INF)
                    System.out.println(graph.vertexes.get(i) + "到" + graph.vertexes.get(j) + "的最短路径长度是" + dis[i][j]
                    + "，最短路径上的最后一个顶点是" + path[i][j]);
                else
                    System.out.println(graph.vertexes.get(i) + "到" + graph.vertexes.get(j) + "不可达");
            }
        }
    }

    // 用邻接矩阵存储的图
    static class MGraph {
        public ArrayList<String> vertexes;  // 顶点信息
        public int[][] edges;   // 邻接矩阵
        public int n;   // 顶点个数
        public int e;   // 边的条数

        public MGraph(ArrayList<String> vertexes, int[][] edges) {
            this.vertexes = vertexes;
            this.edges = edges;
            this.n = vertexes.size();
            for (int[] rows : edges)
                for (int dis : rows)
                    if (dis < INF && dis > 0)
                        ++this.e;
        }
    }
}
```